syntax = "proto3";
package reclaim_witness;

enum TranscriptMessageSenderType {
	TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN = 0;
	TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT = 1;
	TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER = 2;
}

enum ServiceSignatureType {
	SERVICE_SIGNATURE_TYPE_UNKNOWN = 0;
	/**
	 * ETH keys & signature
	 * keys: secp256k1
	 * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
	 */
	SERVICE_SIGNATURE_TYPE_ETH = 1;
}

enum WitnessVersion {
	WITNESS_VERSION_UNKNOWN = 0;
	WITNESS_VERSION_1_0_0 = 1;
	WITNESS_VERSION_1_1_0 = 2;
	WITNESS_VERSION_2_0_0 = 3;
}

enum TLSVersion {
	TLS_VERSION_UNKNOWN = 0;
	TLS_VERSION_1_2 = 2;
	TLS_VERSION_1_3 = 3;
}

enum BeaconType {
	BEACON_TYPE_UNKNOWN = 0;
	BEACON_TYPE_SMART_CONTRACT = 1;
	BEACON_TYPE_RECLAIM_TRUSTED = 2;
}

enum WitnessErrorCode {
	// 0 should be treated as the absence of an error
	WITNESS_ERROR_NO_ERROR = 0;
	WITNESS_ERROR_INTERNAL = 1;
	WITNESS_ERROR_BAD_REQUEST = 2;
	WITNESS_ERROR_NOT_FOUND = 3;
	WITNESS_ERROR_PROXY_ERROR = 4;
}

message TLSPacket {
	bytes recordHeader = 1;
	bytes content = 2;
}

message TranscriptMessage {
	TranscriptMessageSenderType senderType = 1;
	bool redacted = 2;
	/** if redacted, message is empty */
	bytes message = 3;
	bytes packetHeader = 4;
	/**
	 * Length of the plaintext. Only
	 * available for cipher schemes that
	 * don't have padding
	 */
	uint32 plaintextLength = 5;
}

message ProviderClaimData {
	string provider = 1;
	string parameters = 2;
	string owner = 3;
	uint32 timestampS = 4;
	string context = 6;
	/**
	 * identifier of the claim;
	 * Hash of (provider, parameters, context)
	 *
	 * This is different from the claimId returned
	 * from the smart contract
	 */
	string identifier = 8;
	uint32 epoch = 9;
}

message ProviderClaimInfo {
	string provider = 1;
	string parameters = 2;
	string context = 6;
}

message TLSReceipt {
	/** 
	 * host concatenated with port with a colon (:)
	 * eg. localhost:443
	 */
	string hostPort = 1;
	/**
	 * unix timestamp in seconds of the receipt completion
	 */
	uint32 timestampS = 2;
	/** 
	 * the transcript between the server & client
	 * in the order they were received
	 */
	repeated TranscriptMessage transcript = 3;
	/** sign(proto(TLSReceipt w/o signature)) */
	bytes signature = 4;
	/** the version of TLS used */
	TLSVersion tlsVersion = 5;
	/** 
	 * Geo location from which the request was made.
	 * 2 letter ISO country code. Empty if geo location
	 * was not used.
	 */
	string geoLocation = 6;
}

message GetVerifierPublicKeyRequest {
	ServiceSignatureType signatureType = 1;
}

message GetVerifierPublicKeyResponse {
	/** public key of the verifier */
	bytes publicKey = 1;
	/** type of signature being used by the service */
	ServiceSignatureType signatureType = 2;
}

message BeaconIdentifier {
	/** 
	 * type of beacon
	 */
	BeaconType type = 1;
	/** 
	 * ID of the Beacon.
	 * For smart contract, it's the chain ID.
	 */
	string id = 2;
}

message InitialiseSessionRequest {
	/** 
	 * Use if you'd just like a signed receipt
	 * for some custom purpose
	 */
	ReceiptGenerationRequest receiptGenerationRequest = 1;
	/** beacon based version of ProviderClaimRequest */
	BeaconBasedProviderClaimRequest beaconBasedProviderClaimRequest = 3;

	message ReceiptGenerationRequest {
		string host = 1;
		uint32 port = 2;
		/**
		* Geo location from which the request will be made.
		* Provide 2 letter ISO country code. Leave empty
		* if you don't want to use geo location.
		*
		* Geo location is implemented using an https proxy
		* eg. US, IN, GB, etc.
		*/
		string geoLocation = 3;
	}

	message BeaconBasedProviderClaimRequest {
		/** Epoch in which claim is being created */
		uint32 epoch = 1;
		/**
		 * When the claim is being created.
		 * Cannot be more than 10 minutes in the past
		 * or in the future at all
		 */
		uint32 timestampS = 2;
		/** private information to sign */
		ProviderClaimInfo info = 3;
		/** proof of who is making the claim */
		ClaimOwner ownerProof = 4;

		BeaconIdentifier beacon = 5;
	}

	message ClaimOwner {
		/** address of the owner */
		string address = 1;
		/**
		 * signature of proto serialised epoch and info
		 * with the private key
		 */
		bytes signature = 2;
	}
}

message InitialiseSessionResponse {
	/** opaque ID assigned to the client for this request */
	string sessionId = 1;
}

message PushToSessionRequest {
	/** opaque ID assigned to the client for this request */
	string sessionId = 1;
	/**
	 * messages to push, specify in the order
	 * to be sent to the server
	 */
	repeated TLSPacket messages = 2;
}

message PushToSessionResponse {
	/** index of the packet in the server */
	uint32 index = 1;
}

message PullFromSessionRequest {
	/** opaque ID assigned to the client for this request */
	string sessionId = 1;
	/** indicate the version of the client */
	WitnessVersion version = 2;
}

message PullFromSessionResponse {
	/** messages pulled from the server */
	TLSPacket message = 1;
	/** index of the packet in the server */
	uint32 index = 2;
}

message CancelSessionRequest {
	string sessionId = 1;
}

message CancelSessionResponse {
	// empty response
}

message FinaliseSessionRequest {
	string sessionId = 1;
	repeated Block revealBlocks = 2;

	message Block {
		/**
		 * auth tag of the block to reveal
		 * @deprecated specify block using index
		 */
		bytes authTag = 1;
		BlockRevealDirect directReveal = 4;
		BlockRevealZk zkReveal = 5;
		/**
		 * index of the block in the transcript.
		 * (0 indexed -- including msgs from client & server)
		 */
		uint32 index = 6;
	}

	// direct reveal of the block via the key & IV
	// cipher (aes, chacha) for decryption
	// selected based on `cipherSuite`
	// in `FinaliseSessionRequest`
	message BlockRevealDirect {
		/** key for the block */
		bytes key = 1;
		/** IV for the block */
		bytes iv = 2;
		/**
		 * used to generate IV in authenticated
		 * cipher suites
		 */
		uint32 recordNumber = 3;
	}

	// partially or fully reveal the block via a zk proof
	message BlockRevealZk {
		repeated ZKProof proofs = 1;
	}

	message ZKProof {
		/** JSON encoded snarkJS proof */
		string proofJson = 1;
		/** the decrypted ciphertext as output by the ZK proof */
		bytes decryptedRedactedCiphertext = 2;
		/** the plaintext that is fully or partially revealed */
		bytes redactedPlaintext = 3;
		/**
		 * start of this specific ChaCha block
		 * in the redactedPlaintext
		 */
		uint32 startIdx = 4;
	}
}

message FinaliseSessionResponse {
	TLSReceipt receipt = 1;
	ProviderClaimData claimData = 2;
	/** 
	 * signature of `stringifyProviderClaimData(claimData)`
	 */
	bytes signature = 3;
}

message WitnessErrorData {
	WitnessErrorCode code = 1;
	string message = 2;
	string data = 3;
}

message CreateTunnelRequest {
	/**
	 * Assign a unique ID to the client for this tunnel
	 * request. This ID will be used to identify the tunnel
	 * to later send messages or disconnect the tunnel.
	 */
	uint32 id = 1;
	string host = 2;
	uint32 port = 3;
	/**
	 * Geo location from which the request will be made.
	 * Provide 2 letter ISO country code. Leave empty
	 * if you don't want to use geo location.
	 *
	 * Geo location is implemented using an https proxy
	 * eg. US, IN, GB, etc.
	 */
	string geoLocation = 4;
	/**
	 * Optionally provide the initial packet to send upon
	 * connection establishment. Prevents the need to have
	 * another round trip to send the first packet.
	 */
	bytes initialMessage = 5;
}

message DisconnectTunnelRequest {
	uint32 id = 1;
}

message Empty {
	// empty message
}

message TunnelMessage {
	/** ID of the tunnel where this message belongs */
	uint32 tunnelId = 1;
	bytes message = 2;
}

message TunnelDisconnectEvent {
	uint32 tunnelId = 1;
	WitnessErrorData error = 2;
}

message MessageReveal {
	oneof reveal {
		// direct reveal of the block via the key & IV
		// cipher (aes, chacha) for decryption
		// selected based on `cipherSuite`
		// determined by the server hello packet
		MessageRevealDirect directReveal = 1;
		// partially or fully reveal the block via a zk proof
		MessageRevealZk zkReveal = 2;
	}

	message MessageRevealDirect {
		/** key for the block */
		bytes key = 1;
		/** IV for the block */
		bytes iv = 2;
		/**
		* used to generate IV in authenticated
		* cipher suites
		*/
		uint32 recordNumber = 3;
	}

	message MessageRevealZk {
		repeated ZKProof proofs = 1;
	}

	message ZKProof {
		/** JSON encoded snarkJS proof */
		string proofJson = 1;
		/** the decrypted ciphertext as output by the ZK proof */
		bytes decryptedRedactedCiphertext = 2;
		/** the plaintext that is fully or partially revealed */
		bytes redactedPlaintext = 3;
		/**
		* start of this specific ChaCha block
		* in the redactedPlaintext
		*/
		uint32 startIdx = 4;
	}
}

message ClaimTunnelRequest {
	/**
	 * parameters supplied to establish the tunnel
	 * & connect to the end server
	 */
	CreateTunnelRequest request = 1;
	/**
	 * Timestamp of the claim being made.
	 * Cannot be more than 10 minutes in the past
	 * or in the future
	 */
	uint32 timestampS = 2;
	/** claim information to sign */
	ProviderClaimInfo info = 3;
	/**
	 * messages from the client & server
	 * in the order they were sent/received
	 *
	 * Attach a proof (if any) to each message
	 * to reveal the contents of the message inside
	 * 
	 * The revealed messages should support the proving
	 * of the claim as defined in the provider's implementation
	 */
	repeated TranscriptMessage transcript = 4;
	Signatures signatures = 5;

	message Signatures {
		/**
		* signature of ClaimTunnelRequest
		* with empty "signatures" field
		*/
		bytes requestSignature = 1;
	}

	message TranscriptMessage {
		TranscriptMessageSenderType sender = 1;
		bytes message = 2;
		MessageReveal reveal = 3;
	}
}

message ClaimTunnelResponse {
	/**
	 * The original request that was made to claim the tunnel
	 */
	ClaimTunnelRequest request = 1;
	oneof result {
		ProviderClaimData claim = 2;
		WitnessErrorData error = 3;
	}
	Signatures signatures = 4;

	message Signatures {
		/** 
		* signature of `stringifyProviderClaimData(claim)`,
		* if the claim was successful
		*/
		bytes claimSignature = 1;
		/**
		 * signature of the complete ClaimTunnelResponse
		 * structure with empty "signatures" field
		 */
		bytes resultSignature = 2;
	}
}

message InitRequest {
	/** User ID */
	string userId = 1;
	/** Witness client version */
	WitnessVersion clientVersion = 2;
	/** Signature type used & expected by the user */
	ServiceSignatureType signatureType = 3;
}

message ReclaimRPCMessage {
	/**
	 * Per connection unique RPC message ID. Either party sending a
	 * duplicate ID will do nothing except confuse the other party.
	 *
	 * For response messages, the ID should be the same as the request
	 * to which it is responding.
	 */
	uint64 id = 1;
	// message must be one of the following
	oneof message {
		/**
		 * Response to the init request.
		 * The request must be sent in the WebSocket URL
		 * as a query parameter.
		 * `?initRequest=base64(proto(InitRequest))`
		 * */
		Empty initResponse = 2;
		/**
		 * Data representing an error in the WebSocket connection.
		 * The party sending this message should close the connection
		 * immediately after sending this message.
		 */
		WitnessErrorData connectionTerminationAlert = 3;
		/**
		 * Data representing an error in the witness's
		 * request to the server. This should be sent in case
		 * there was an error in processing the request.
		 */
		WitnessErrorData requestError = 4;
		/**
		 * Create a tunnel to the specified host & port.
		 */
		CreateTunnelRequest createTunnelRequest = 5;
		Empty createTunnelResponse = 6;
		/**
		 * Disconnect a tunnel.
		 */
		DisconnectTunnelRequest disconnectTunnelRequest = 7;
		Empty disconnectTunnelResponse = 8;
		/**
		 * Message to send through a tunnel. Client can send
		 * this message to forward data to the server.
		 */
		TunnelMessage tunnelMessage = 9;
		/**
		 * Event indicating that a tunnel has been disconnected.
		 * The client should not send any more messages through
		 * this tunnel.
		 */
		TunnelDisconnectEvent tunnelDisconnectEvent = 10;
		/**
		 * Using the transcript of a tunnel, make a claim.
		 * The tunnel must be disconnected before making a claim.
		 */
		ClaimTunnelRequest claimTunnelRequest = 11;
		ClaimTunnelResponse claimTunnelResponse = 12;
	}
}

service ReclaimWitness {
	/** get the x25519 public key of the verifier that can be used to verify authenticity of receipts & credentials */
	rpc GetVerifierPublicKey(GetVerifierPublicKeyRequest) returns (GetVerifierPublicKeyResponse) {}
	
	/** initialise a new TLS verification session with the verifier */
	rpc initialiseSession(InitialiseSessionRequest) returns (InitialiseSessionResponse);
	/** push blocks to the session */
	rpc PushToSession(PushToSessionRequest) returns (PushToSessionResponse);
	/** listen to blocks from the session */
	rpc PullFromSession(PullFromSessionRequest) returns (stream PullFromSessionResponse);
	/** cancel and destroy the session */
	rpc CancelSession(CancelSessionRequest) returns (CancelSessionResponse);
	/** finalise the session, and generate the receipt & provider signature */
	rpc FinaliseSession(FinaliseSessionRequest) returns (FinaliseSessionResponse);
}