// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.174.0
//   protoc               v3.21.12
// source: api.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "reclaim_witness";

export enum TranscriptMessageSenderType {
  TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN = 0,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT = 1,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER = 2,
  UNRECOGNIZED = -1,
}

export function transcriptMessageSenderTypeFromJSON(object: any): TranscriptMessageSenderType {
  switch (object) {
    case 0:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN;
    case 1:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT;
    case 2:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TranscriptMessageSenderType.UNRECOGNIZED;
  }
}

export function transcriptMessageSenderTypeToJSON(object: TranscriptMessageSenderType): string {
  switch (object) {
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER";
    case TranscriptMessageSenderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ServiceSignatureType {
  SERVICE_SIGNATURE_TYPE_UNKNOWN = 0,
  /**
   * SERVICE_SIGNATURE_TYPE_ETH - ETH keys & signature
   * keys: secp256k1
   * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
   */
  SERVICE_SIGNATURE_TYPE_ETH = 1,
  UNRECOGNIZED = -1,
}

export function serviceSignatureTypeFromJSON(object: any): ServiceSignatureType {
  switch (object) {
    case 0:
    case "SERVICE_SIGNATURE_TYPE_UNKNOWN":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN;
    case 1:
    case "SERVICE_SIGNATURE_TYPE_ETH":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceSignatureType.UNRECOGNIZED;
  }
}

export function serviceSignatureTypeToJSON(object: ServiceSignatureType): string {
  switch (object) {
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN:
      return "SERVICE_SIGNATURE_TYPE_UNKNOWN";
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH:
      return "SERVICE_SIGNATURE_TYPE_ETH";
    case ServiceSignatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WitnessVersion {
  WITNESS_VERSION_UNKNOWN = 0,
  WITNESS_VERSION_1_0_0 = 1,
  WITNESS_VERSION_1_1_0 = 2,
  WITNESS_VERSION_2_0_0 = 3,
  UNRECOGNIZED = -1,
}

export function witnessVersionFromJSON(object: any): WitnessVersion {
  switch (object) {
    case 0:
    case "WITNESS_VERSION_UNKNOWN":
      return WitnessVersion.WITNESS_VERSION_UNKNOWN;
    case 1:
    case "WITNESS_VERSION_1_0_0":
      return WitnessVersion.WITNESS_VERSION_1_0_0;
    case 2:
    case "WITNESS_VERSION_1_1_0":
      return WitnessVersion.WITNESS_VERSION_1_1_0;
    case 3:
    case "WITNESS_VERSION_2_0_0":
      return WitnessVersion.WITNESS_VERSION_2_0_0;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WitnessVersion.UNRECOGNIZED;
  }
}

export function witnessVersionToJSON(object: WitnessVersion): string {
  switch (object) {
    case WitnessVersion.WITNESS_VERSION_UNKNOWN:
      return "WITNESS_VERSION_UNKNOWN";
    case WitnessVersion.WITNESS_VERSION_1_0_0:
      return "WITNESS_VERSION_1_0_0";
    case WitnessVersion.WITNESS_VERSION_1_1_0:
      return "WITNESS_VERSION_1_1_0";
    case WitnessVersion.WITNESS_VERSION_2_0_0:
      return "WITNESS_VERSION_2_0_0";
    case WitnessVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TLSVersion {
  TLS_VERSION_UNKNOWN = 0,
  TLS_VERSION_1_2 = 2,
  TLS_VERSION_1_3 = 3,
  UNRECOGNIZED = -1,
}

export function tLSVersionFromJSON(object: any): TLSVersion {
  switch (object) {
    case 0:
    case "TLS_VERSION_UNKNOWN":
      return TLSVersion.TLS_VERSION_UNKNOWN;
    case 2:
    case "TLS_VERSION_1_2":
      return TLSVersion.TLS_VERSION_1_2;
    case 3:
    case "TLS_VERSION_1_3":
      return TLSVersion.TLS_VERSION_1_3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TLSVersion.UNRECOGNIZED;
  }
}

export function tLSVersionToJSON(object: TLSVersion): string {
  switch (object) {
    case TLSVersion.TLS_VERSION_UNKNOWN:
      return "TLS_VERSION_UNKNOWN";
    case TLSVersion.TLS_VERSION_1_2:
      return "TLS_VERSION_1_2";
    case TLSVersion.TLS_VERSION_1_3:
      return "TLS_VERSION_1_3";
    case TLSVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BeaconType {
  BEACON_TYPE_UNKNOWN = 0,
  BEACON_TYPE_SMART_CONTRACT = 1,
  BEACON_TYPE_RECLAIM_TRUSTED = 2,
  UNRECOGNIZED = -1,
}

export function beaconTypeFromJSON(object: any): BeaconType {
  switch (object) {
    case 0:
    case "BEACON_TYPE_UNKNOWN":
      return BeaconType.BEACON_TYPE_UNKNOWN;
    case 1:
    case "BEACON_TYPE_SMART_CONTRACT":
      return BeaconType.BEACON_TYPE_SMART_CONTRACT;
    case 2:
    case "BEACON_TYPE_RECLAIM_TRUSTED":
      return BeaconType.BEACON_TYPE_RECLAIM_TRUSTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BeaconType.UNRECOGNIZED;
  }
}

export function beaconTypeToJSON(object: BeaconType): string {
  switch (object) {
    case BeaconType.BEACON_TYPE_UNKNOWN:
      return "BEACON_TYPE_UNKNOWN";
    case BeaconType.BEACON_TYPE_SMART_CONTRACT:
      return "BEACON_TYPE_SMART_CONTRACT";
    case BeaconType.BEACON_TYPE_RECLAIM_TRUSTED:
      return "BEACON_TYPE_RECLAIM_TRUSTED";
    case BeaconType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WitnessErrorCode {
  /** WITNESS_ERROR_NO_ERROR - 0 should be treated as the absence of an error */
  WITNESS_ERROR_NO_ERROR = 0,
  WITNESS_ERROR_INTERNAL = 1,
  WITNESS_ERROR_BAD_REQUEST = 2,
  WITNESS_ERROR_NOT_FOUND = 3,
  WITNESS_ERROR_PROXY_ERROR = 4,
  WITNESS_ERROR_INVALID_CLAIM = 5,
  UNRECOGNIZED = -1,
}

export function witnessErrorCodeFromJSON(object: any): WitnessErrorCode {
  switch (object) {
    case 0:
    case "WITNESS_ERROR_NO_ERROR":
      return WitnessErrorCode.WITNESS_ERROR_NO_ERROR;
    case 1:
    case "WITNESS_ERROR_INTERNAL":
      return WitnessErrorCode.WITNESS_ERROR_INTERNAL;
    case 2:
    case "WITNESS_ERROR_BAD_REQUEST":
      return WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST;
    case 3:
    case "WITNESS_ERROR_NOT_FOUND":
      return WitnessErrorCode.WITNESS_ERROR_NOT_FOUND;
    case 4:
    case "WITNESS_ERROR_PROXY_ERROR":
      return WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR;
    case 5:
    case "WITNESS_ERROR_INVALID_CLAIM":
      return WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WitnessErrorCode.UNRECOGNIZED;
  }
}

export function witnessErrorCodeToJSON(object: WitnessErrorCode): string {
  switch (object) {
    case WitnessErrorCode.WITNESS_ERROR_NO_ERROR:
      return "WITNESS_ERROR_NO_ERROR";
    case WitnessErrorCode.WITNESS_ERROR_INTERNAL:
      return "WITNESS_ERROR_INTERNAL";
    case WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST:
      return "WITNESS_ERROR_BAD_REQUEST";
    case WitnessErrorCode.WITNESS_ERROR_NOT_FOUND:
      return "WITNESS_ERROR_NOT_FOUND";
    case WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR:
      return "WITNESS_ERROR_PROXY_ERROR";
    case WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM:
      return "WITNESS_ERROR_INVALID_CLAIM";
    case WitnessErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TLSPacket {
  recordHeader: Uint8Array;
  content: Uint8Array;
}

export interface TranscriptMessage {
  senderType: TranscriptMessageSenderType;
  redacted: boolean;
  /** if redacted, message is empty */
  message: Uint8Array;
  packetHeader: Uint8Array;
  /**
   * Length of the plaintext. Only
   * available for cipher schemes that
   * don't have padding
   */
  plaintextLength: number;
}

export interface ProviderClaimData {
  provider: string;
  parameters: string;
  owner: string;
  timestampS: number;
  context: string;
  /**
   * identifier of the claim;
   * Hash of (provider, parameters, context)
   *
   * This is different from the claimId returned
   * from the smart contract
   */
  identifier: string;
  epoch: number;
}

export interface ProviderClaimInfo {
  provider: string;
  parameters: string;
  context: string;
}

export interface TLSReceipt {
  /**
   * host concatenated with port with a colon (:)
   * eg. localhost:443
   */
  hostPort: string;
  /** unix timestamp in seconds of the receipt completion */
  timestampS: number;
  /**
   * the transcript between the server & client
   * in the order they were received
   */
  transcript: TranscriptMessage[];
  /** sign(proto(TLSReceipt w/o signature)) */
  signature: Uint8Array;
  /** the version of TLS used */
  tlsVersion: TLSVersion;
  /**
   * Geo location from which the request was made.
   * 2 letter ISO country code. Empty if geo location
   * was not used.
   */
  geoLocation: string;
}

export interface GetVerifierPublicKeyRequest {
  signatureType: ServiceSignatureType;
}

export interface GetVerifierPublicKeyResponse {
  /** public key of the verifier */
  publicKey: Uint8Array;
  /** type of signature being used by the service */
  signatureType: ServiceSignatureType;
}

export interface BeaconIdentifier {
  /** type of beacon */
  type: BeaconType;
  /**
   * ID of the Beacon.
   * For smart contract, it's the chain ID.
   */
  id: string;
}

export interface InitialiseSessionRequest {
  /**
   * Use if you'd just like a signed receipt
   * for some custom purpose
   */
  receiptGenerationRequest:
    | InitialiseSessionRequest_ReceiptGenerationRequest
    | undefined;
  /** beacon based version of ProviderClaimRequest */
  beaconBasedProviderClaimRequest: InitialiseSessionRequest_BeaconBasedProviderClaimRequest | undefined;
}

export interface InitialiseSessionRequest_ReceiptGenerationRequest {
  host: string;
  port: number;
  /**
   * Geo location from which the request will be made.
   * Provide 2 letter ISO country code. Leave empty
   * if you don't want to use geo location.
   *
   * Geo location is implemented using an https proxy
   * eg. US, IN, GB, etc.
   */
  geoLocation: string;
}

export interface InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
  /** Epoch in which claim is being created */
  epoch: number;
  /**
   * When the claim is being created.
   * Cannot be more than 10 minutes in the past
   * or in the future at all
   */
  timestampS: number;
  /** private information to sign */
  info:
    | ProviderClaimInfo
    | undefined;
  /** proof of who is making the claim */
  ownerProof: InitialiseSessionRequest_ClaimOwner | undefined;
  beacon: BeaconIdentifier | undefined;
}

export interface InitialiseSessionRequest_ClaimOwner {
  /** address of the owner */
  address: string;
  /**
   * signature of proto serialised epoch and info
   * with the private key
   */
  signature: Uint8Array;
}

export interface InitialiseSessionResponse {
  /** opaque ID assigned to the client for this request */
  sessionId: string;
}

export interface PushToSessionRequest {
  /** opaque ID assigned to the client for this request */
  sessionId: string;
  /**
   * messages to push, specify in the order
   * to be sent to the server
   */
  messages: TLSPacket[];
}

export interface PushToSessionResponse {
  /** index of the packet in the server */
  index: number;
}

export interface PullFromSessionRequest {
  /** opaque ID assigned to the client for this request */
  sessionId: string;
  /** indicate the version of the client */
  version: WitnessVersion;
}

export interface PullFromSessionResponse {
  /** messages pulled from the server */
  message:
    | TLSPacket
    | undefined;
  /** index of the packet in the server */
  index: number;
}

export interface CancelSessionRequest {
  sessionId: string;
}

/** empty response */
export interface CancelSessionResponse {
}

export interface FinaliseSessionRequest {
  sessionId: string;
  revealBlocks: FinaliseSessionRequest_Block[];
}

export interface FinaliseSessionRequest_Block {
  /**
   * auth tag of the block to reveal
   * @deprecated specify block using index
   */
  authTag: Uint8Array;
  directReveal: FinaliseSessionRequest_BlockRevealDirect | undefined;
  zkReveal:
    | FinaliseSessionRequest_BlockRevealZk
    | undefined;
  /**
   * index of the block in the transcript.
   * (0 indexed -- including msgs from client & server)
   */
  index: number;
}

/**
 * direct reveal of the block via the key & IV
 * cipher (aes, chacha) for decryption
 * selected based on `cipherSuite`
 * in `FinaliseSessionRequest`
 */
export interface FinaliseSessionRequest_BlockRevealDirect {
  /** key for the block */
  key: Uint8Array;
  /** IV for the block */
  iv: Uint8Array;
  /**
   * used to generate IV in authenticated
   * cipher suites
   */
  recordNumber: number;
}

/** partially or fully reveal the block via a zk proof */
export interface FinaliseSessionRequest_BlockRevealZk {
  proofs: FinaliseSessionRequest_ZKProof[];
}

export interface FinaliseSessionRequest_ZKProof {
  /** JSON encoded snarkJS proof */
  proofJson: string;
  /** the decrypted ciphertext as output by the ZK proof */
  decryptedRedactedCiphertext: Uint8Array;
  /** the plaintext that is fully or partially revealed */
  redactedPlaintext: Uint8Array;
  /**
   * start of this specific ChaCha block
   * in the redactedPlaintext
   */
  startIdx: number;
}

export interface FinaliseSessionResponse {
  receipt: TLSReceipt | undefined;
  claimData:
    | ProviderClaimData
    | undefined;
  /** signature of `stringifyProviderClaimData(claimData)` */
  signature: Uint8Array;
}

export interface WitnessErrorData {
  code: WitnessErrorCode;
  message: string;
  data: string;
}

export interface CreateTunnelRequest {
  /**
   * Assign a unique ID to the client for this tunnel
   * request. This ID will be used to identify the tunnel
   * to later send messages or disconnect the tunnel.
   */
  id: number;
  host: string;
  port: number;
  /**
   * Geo location from which the request will be made.
   * Provide 2 letter ISO country code. Leave empty
   * if you don't want to use geo location.
   *
   * Geo location is implemented using an https proxy
   * eg. US, IN, GB, etc.
   */
  geoLocation: string;
  /**
   * Optionally provide the initial packet to send upon
   * connection establishment. Prevents the need to have
   * another round trip to send the first packet.
   */
  initialMessage: Uint8Array;
}

export interface DisconnectTunnelRequest {
  id: number;
}

/** empty message */
export interface Empty {
}

export interface TunnelMessage {
  /** ID of the tunnel where this message belongs */
  tunnelId: number;
  message: Uint8Array;
}

export interface TunnelDisconnectEvent {
  tunnelId: number;
  error: WitnessErrorData | undefined;
}

export interface MessageReveal {
  /**
   * direct reveal of the block via the key & IV
   * cipher (aes, chacha) for decryption
   * selected based on `cipherSuite`
   * determined by the server hello packet
   */
  directReveal?:
    | MessageReveal_MessageRevealDirect
    | undefined;
  /** partially or fully reveal the block via a zk proof */
  zkReveal?: MessageReveal_MessageRevealZk | undefined;
}

export interface MessageReveal_MessageRevealDirect {
  /** key for the block */
  key: Uint8Array;
  /** IV for the block */
  iv: Uint8Array;
  /**
   * used to generate IV in authenticated
   * cipher suites
   */
  recordNumber: number;
}

export interface MessageReveal_MessageRevealZk {
  proofs: MessageReveal_ZKProof[];
}

export interface MessageReveal_ZKProof {
  /** JSON encoded snarkJS proof */
  proofJson: string;
  /** the decrypted ciphertext as output by the ZK proof */
  decryptedRedactedCiphertext: Uint8Array;
  /** the plaintext that is fully or partially revealed */
  redactedPlaintext: Uint8Array;
  /**
   * start of this specific ChaCha block
   * in the redactedPlaintext
   */
  startIdx: number;
}

export interface ClaimTunnelRequest {
  /**
   * parameters supplied to establish the tunnel
   * & connect to the end server
   */
  request:
    | CreateTunnelRequest
    | undefined;
  /**
   * Timestamp of the claim being made.
   * Cannot be more than 10 minutes in the past
   * or in the future
   */
  timestampS: number;
  /** claim information to sign */
  info:
    | ProviderClaimInfo
    | undefined;
  /**
   * messages from the client & server
   * in the order they were sent/received
   *
   * Attach a proof (if any) to each message
   * to reveal the contents of the message inside
   *
   * The revealed messages should support the proving
   * of the claim as defined in the provider's implementation
   */
  transcript: ClaimTunnelRequest_TranscriptMessage[];
  signatures: ClaimTunnelRequest_Signatures | undefined;
}

export interface ClaimTunnelRequest_Signatures {
  /**
   * signature of ClaimTunnelRequest
   * with empty "signatures" field
   */
  requestSignature: Uint8Array;
}

export interface ClaimTunnelRequest_TranscriptMessage {
  sender: TranscriptMessageSenderType;
  message: Uint8Array;
  reveal: MessageReveal | undefined;
}

export interface ClaimTunnelResponse {
  /** The original request that was made to claim the tunnel */
  request: ClaimTunnelRequest | undefined;
  claim?: ProviderClaimData | undefined;
  error?: WitnessErrorData | undefined;
  signatures: ClaimTunnelResponse_Signatures | undefined;
}

export interface ClaimTunnelResponse_Signatures {
  /**
   * signature of `stringifyProviderClaimData(claim)`,
   * if the claim was successful
   */
  claimSignature: Uint8Array;
  /**
   * signature of the complete ClaimTunnelResponse
   * structure with empty "signatures" field
   */
  resultSignature: Uint8Array;
}

export interface InitRequest {
  /** User ID */
  userId: string;
  /** Witness client version */
  clientVersion: WitnessVersion;
  /** Signature type used & expected by the user */
  signatureType: ServiceSignatureType;
}

export interface ReclaimRPCMessage {
  /**
   * Per connection unique RPC message ID. Either party sending a
   * duplicate ID will do nothing except confuse the other party.
   *
   * For response messages, the ID should be the same as the request
   * to which it is responding.
   */
  id: number;
  /**
   * Response to the init request.
   * The request must be sent in the WebSocket URL
   * as a query parameter.
   * `?initRequest=base64(proto(InitRequest))`
   */
  initResponse?:
    | Empty
    | undefined;
  /**
   * Data representing an error in the WebSocket connection.
   * The party sending this message should close the connection
   * immediately after sending this message.
   */
  connectionTerminationAlert?:
    | WitnessErrorData
    | undefined;
  /**
   * Data representing an error in the witness's
   * request to the server. This should be sent in case
   * there was an error in processing the request.
   */
  requestError?:
    | WitnessErrorData
    | undefined;
  /** Create a tunnel to the specified host & port. */
  createTunnelRequest?: CreateTunnelRequest | undefined;
  createTunnelResponse?:
    | Empty
    | undefined;
  /** Disconnect a tunnel. */
  disconnectTunnelRequest?: DisconnectTunnelRequest | undefined;
  disconnectTunnelResponse?:
    | Empty
    | undefined;
  /**
   * Message to send through a tunnel. Client can send
   * this message to forward data to the server.
   */
  tunnelMessage?:
    | TunnelMessage
    | undefined;
  /**
   * Event indicating that a tunnel has been disconnected.
   * The client should not send any more messages through
   * this tunnel.
   */
  tunnelDisconnectEvent?:
    | TunnelDisconnectEvent
    | undefined;
  /**
   * Using the transcript of a tunnel, make a claim.
   * The tunnel must be disconnected before making a claim.
   */
  claimTunnelRequest?: ClaimTunnelRequest | undefined;
  claimTunnelResponse?: ClaimTunnelResponse | undefined;
}

function createBaseTLSPacket(): TLSPacket {
  return { recordHeader: new Uint8Array(0), content: new Uint8Array(0) };
}

export const TLSPacket = {
  encode(message: TLSPacket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.recordHeader.length !== 0) {
      writer.uint32(10).bytes(message.recordHeader);
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TLSPacket {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSPacket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recordHeader = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSPacket {
    return {
      recordHeader: isSet(object.recordHeader) ? bytesFromBase64(object.recordHeader) : new Uint8Array(0),
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
    };
  },

  toJSON(message: TLSPacket): unknown {
    const obj: any = {};
    if (message.recordHeader.length !== 0) {
      obj.recordHeader = base64FromBytes(message.recordHeader);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<TLSPacket>): TLSPacket {
    return TLSPacket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TLSPacket>): TLSPacket {
    const message = createBaseTLSPacket();
    message.recordHeader = object.recordHeader ?? new Uint8Array(0);
    message.content = object.content ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTranscriptMessage(): TranscriptMessage {
  return {
    senderType: 0,
    redacted: false,
    message: new Uint8Array(0),
    packetHeader: new Uint8Array(0),
    plaintextLength: 0,
  };
}

export const TranscriptMessage = {
  encode(message: TranscriptMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.senderType !== 0) {
      writer.uint32(8).int32(message.senderType);
    }
    if (message.redacted !== false) {
      writer.uint32(16).bool(message.redacted);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    if (message.packetHeader.length !== 0) {
      writer.uint32(34).bytes(message.packetHeader);
    }
    if (message.plaintextLength !== 0) {
      writer.uint32(40).uint32(message.plaintextLength);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TranscriptMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTranscriptMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.senderType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.redacted = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.packetHeader = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.plaintextLength = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TranscriptMessage {
    return {
      senderType: isSet(object.senderType) ? transcriptMessageSenderTypeFromJSON(object.senderType) : 0,
      redacted: isSet(object.redacted) ? globalThis.Boolean(object.redacted) : false,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      packetHeader: isSet(object.packetHeader) ? bytesFromBase64(object.packetHeader) : new Uint8Array(0),
      plaintextLength: isSet(object.plaintextLength) ? globalThis.Number(object.plaintextLength) : 0,
    };
  },

  toJSON(message: TranscriptMessage): unknown {
    const obj: any = {};
    if (message.senderType !== 0) {
      obj.senderType = transcriptMessageSenderTypeToJSON(message.senderType);
    }
    if (message.redacted !== false) {
      obj.redacted = message.redacted;
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.packetHeader.length !== 0) {
      obj.packetHeader = base64FromBytes(message.packetHeader);
    }
    if (message.plaintextLength !== 0) {
      obj.plaintextLength = Math.round(message.plaintextLength);
    }
    return obj;
  },

  create(base?: DeepPartial<TranscriptMessage>): TranscriptMessage {
    return TranscriptMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TranscriptMessage>): TranscriptMessage {
    const message = createBaseTranscriptMessage();
    message.senderType = object.senderType ?? 0;
    message.redacted = object.redacted ?? false;
    message.message = object.message ?? new Uint8Array(0);
    message.packetHeader = object.packetHeader ?? new Uint8Array(0);
    message.plaintextLength = object.plaintextLength ?? 0;
    return message;
  },
};

function createBaseProviderClaimData(): ProviderClaimData {
  return { provider: "", parameters: "", owner: "", timestampS: 0, context: "", identifier: "", epoch: 0 };
}

export const ProviderClaimData = {
  encode(message: ProviderClaimData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.timestampS !== 0) {
      writer.uint32(32).uint32(message.timestampS);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    if (message.identifier !== "") {
      writer.uint32(66).string(message.identifier);
    }
    if (message.epoch !== 0) {
      writer.uint32(72).uint32(message.epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderClaimData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.identifier = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.epoch = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: ProviderClaimData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimData>): ProviderClaimData {
    return ProviderClaimData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimData>): ProviderClaimData {
    const message = createBaseProviderClaimData();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.owner = object.owner ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.context = object.context ?? "";
    message.identifier = object.identifier ?? "";
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseProviderClaimInfo(): ProviderClaimInfo {
  return { provider: "", parameters: "", context: "" };
}

export const ProviderClaimInfo = {
  encode(message: ProviderClaimInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderClaimInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimInfo {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ProviderClaimInfo): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    return ProviderClaimInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    const message = createBaseProviderClaimInfo();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseTLSReceipt(): TLSReceipt {
  return { hostPort: "", timestampS: 0, transcript: [], signature: new Uint8Array(0), tlsVersion: 0, geoLocation: "" };
}

export const TLSReceipt = {
  encode(message: TLSReceipt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hostPort !== "") {
      writer.uint32(10).string(message.hostPort);
    }
    if (message.timestampS !== 0) {
      writer.uint32(16).uint32(message.timestampS);
    }
    for (const v of message.transcript) {
      TranscriptMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    if (message.tlsVersion !== 0) {
      writer.uint32(40).int32(message.tlsVersion);
    }
    if (message.geoLocation !== "") {
      writer.uint32(50).string(message.geoLocation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TLSReceipt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTLSReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostPort = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transcript.push(TranscriptMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.tlsVersion = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.geoLocation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TLSReceipt {
    return {
      hostPort: isSet(object.hostPort) ? globalThis.String(object.hostPort) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      transcript: globalThis.Array.isArray(object?.transcript)
        ? object.transcript.map((e: any) => TranscriptMessage.fromJSON(e))
        : [],
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      tlsVersion: isSet(object.tlsVersion) ? tLSVersionFromJSON(object.tlsVersion) : 0,
      geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
    };
  },

  toJSON(message: TLSReceipt): unknown {
    const obj: any = {};
    if (message.hostPort !== "") {
      obj.hostPort = message.hostPort;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.transcript?.length) {
      obj.transcript = message.transcript.map((e) => TranscriptMessage.toJSON(e));
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.tlsVersion !== 0) {
      obj.tlsVersion = tLSVersionToJSON(message.tlsVersion);
    }
    if (message.geoLocation !== "") {
      obj.geoLocation = message.geoLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<TLSReceipt>): TLSReceipt {
    return TLSReceipt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TLSReceipt>): TLSReceipt {
    const message = createBaseTLSReceipt();
    message.hostPort = object.hostPort ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.transcript = object.transcript?.map((e) => TranscriptMessage.fromPartial(e)) || [];
    message.signature = object.signature ?? new Uint8Array(0);
    message.tlsVersion = object.tlsVersion ?? 0;
    message.geoLocation = object.geoLocation ?? "";
    return message;
  },
};

function createBaseGetVerifierPublicKeyRequest(): GetVerifierPublicKeyRequest {
  return { signatureType: 0 };
}

export const GetVerifierPublicKeyRequest = {
  encode(message: GetVerifierPublicKeyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signatureType !== 0) {
      writer.uint32(8).int32(message.signatureType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetVerifierPublicKeyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVerifierPublicKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVerifierPublicKeyRequest {
    return { signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0 };
  },

  toJSON(message: GetVerifierPublicKeyRequest): unknown {
    const obj: any = {};
    if (message.signatureType !== 0) {
      obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
    }
    return obj;
  },

  create(base?: DeepPartial<GetVerifierPublicKeyRequest>): GetVerifierPublicKeyRequest {
    return GetVerifierPublicKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVerifierPublicKeyRequest>): GetVerifierPublicKeyRequest {
    const message = createBaseGetVerifierPublicKeyRequest();
    message.signatureType = object.signatureType ?? 0;
    return message;
  },
};

function createBaseGetVerifierPublicKeyResponse(): GetVerifierPublicKeyResponse {
  return { publicKey: new Uint8Array(0), signatureType: 0 };
}

export const GetVerifierPublicKeyResponse = {
  encode(message: GetVerifierPublicKeyResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    if (message.signatureType !== 0) {
      writer.uint32(16).int32(message.signatureType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetVerifierPublicKeyResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVerifierPublicKeyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVerifierPublicKeyResponse {
    return {
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0,
    };
  },

  toJSON(message: GetVerifierPublicKeyResponse): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.signatureType !== 0) {
      obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
    }
    return obj;
  },

  create(base?: DeepPartial<GetVerifierPublicKeyResponse>): GetVerifierPublicKeyResponse {
    return GetVerifierPublicKeyResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVerifierPublicKeyResponse>): GetVerifierPublicKeyResponse {
    const message = createBaseGetVerifierPublicKeyResponse();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.signatureType = object.signatureType ?? 0;
    return message;
  },
};

function createBaseBeaconIdentifier(): BeaconIdentifier {
  return { type: 0, id: "" };
}

export const BeaconIdentifier = {
  encode(message: BeaconIdentifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BeaconIdentifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeaconIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeaconIdentifier {
    return {
      type: isSet(object.type) ? beaconTypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: BeaconIdentifier): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = beaconTypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<BeaconIdentifier>): BeaconIdentifier {
    return BeaconIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BeaconIdentifier>): BeaconIdentifier {
    const message = createBaseBeaconIdentifier();
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseInitialiseSessionRequest(): InitialiseSessionRequest {
  return { receiptGenerationRequest: undefined, beaconBasedProviderClaimRequest: undefined };
}

export const InitialiseSessionRequest = {
  encode(message: InitialiseSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.receiptGenerationRequest !== undefined) {
      InitialiseSessionRequest_ReceiptGenerationRequest.encode(
        message.receiptGenerationRequest,
        writer.uint32(10).fork(),
      ).ldelim();
    }
    if (message.beaconBasedProviderClaimRequest !== undefined) {
      InitialiseSessionRequest_BeaconBasedProviderClaimRequest.encode(
        message.beaconBasedProviderClaimRequest,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitialiseSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialiseSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receiptGenerationRequest = InitialiseSessionRequest_ReceiptGenerationRequest.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beaconBasedProviderClaimRequest = InitialiseSessionRequest_BeaconBasedProviderClaimRequest.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialiseSessionRequest {
    return {
      receiptGenerationRequest: isSet(object.receiptGenerationRequest)
        ? InitialiseSessionRequest_ReceiptGenerationRequest.fromJSON(object.receiptGenerationRequest)
        : undefined,
      beaconBasedProviderClaimRequest: isSet(object.beaconBasedProviderClaimRequest)
        ? InitialiseSessionRequest_BeaconBasedProviderClaimRequest.fromJSON(object.beaconBasedProviderClaimRequest)
        : undefined,
    };
  },

  toJSON(message: InitialiseSessionRequest): unknown {
    const obj: any = {};
    if (message.receiptGenerationRequest !== undefined) {
      obj.receiptGenerationRequest = InitialiseSessionRequest_ReceiptGenerationRequest.toJSON(
        message.receiptGenerationRequest,
      );
    }
    if (message.beaconBasedProviderClaimRequest !== undefined) {
      obj.beaconBasedProviderClaimRequest = InitialiseSessionRequest_BeaconBasedProviderClaimRequest.toJSON(
        message.beaconBasedProviderClaimRequest,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<InitialiseSessionRequest>): InitialiseSessionRequest {
    return InitialiseSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialiseSessionRequest>): InitialiseSessionRequest {
    const message = createBaseInitialiseSessionRequest();
    message.receiptGenerationRequest =
      (object.receiptGenerationRequest !== undefined && object.receiptGenerationRequest !== null)
        ? InitialiseSessionRequest_ReceiptGenerationRequest.fromPartial(object.receiptGenerationRequest)
        : undefined;
    message.beaconBasedProviderClaimRequest =
      (object.beaconBasedProviderClaimRequest !== undefined && object.beaconBasedProviderClaimRequest !== null)
        ? InitialiseSessionRequest_BeaconBasedProviderClaimRequest.fromPartial(object.beaconBasedProviderClaimRequest)
        : undefined;
    return message;
  },
};

function createBaseInitialiseSessionRequest_ReceiptGenerationRequest(): InitialiseSessionRequest_ReceiptGenerationRequest {
  return { host: "", port: 0, geoLocation: "" };
}

export const InitialiseSessionRequest_ReceiptGenerationRequest = {
  encode(
    message: InitialiseSessionRequest_ReceiptGenerationRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.geoLocation !== "") {
      writer.uint32(26).string(message.geoLocation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitialiseSessionRequest_ReceiptGenerationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialiseSessionRequest_ReceiptGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.geoLocation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialiseSessionRequest_ReceiptGenerationRequest {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
    };
  },

  toJSON(message: InitialiseSessionRequest_ReceiptGenerationRequest): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.geoLocation !== "") {
      obj.geoLocation = message.geoLocation;
    }
    return obj;
  },

  create(
    base?: DeepPartial<InitialiseSessionRequest_ReceiptGenerationRequest>,
  ): InitialiseSessionRequest_ReceiptGenerationRequest {
    return InitialiseSessionRequest_ReceiptGenerationRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InitialiseSessionRequest_ReceiptGenerationRequest>,
  ): InitialiseSessionRequest_ReceiptGenerationRequest {
    const message = createBaseInitialiseSessionRequest_ReceiptGenerationRequest();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.geoLocation = object.geoLocation ?? "";
    return message;
  },
};

function createBaseInitialiseSessionRequest_BeaconBasedProviderClaimRequest(): InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
  return { epoch: 0, timestampS: 0, info: undefined, ownerProof: undefined, beacon: undefined };
}

export const InitialiseSessionRequest_BeaconBasedProviderClaimRequest = {
  encode(
    message: InitialiseSessionRequest_BeaconBasedProviderClaimRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.epoch !== 0) {
      writer.uint32(8).uint32(message.epoch);
    }
    if (message.timestampS !== 0) {
      writer.uint32(16).uint32(message.timestampS);
    }
    if (message.info !== undefined) {
      ProviderClaimInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
    }
    if (message.ownerProof !== undefined) {
      InitialiseSessionRequest_ClaimOwner.encode(message.ownerProof, writer.uint32(34).fork()).ldelim();
    }
    if (message.beacon !== undefined) {
      BeaconIdentifier.encode(message.beacon, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialiseSessionRequest_BeaconBasedProviderClaimRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.epoch = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.info = ProviderClaimInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ownerProof = InitialiseSessionRequest_ClaimOwner.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.beacon = BeaconIdentifier.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
    return {
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      info: isSet(object.info) ? ProviderClaimInfo.fromJSON(object.info) : undefined,
      ownerProof: isSet(object.ownerProof)
        ? InitialiseSessionRequest_ClaimOwner.fromJSON(object.ownerProof)
        : undefined,
      beacon: isSet(object.beacon) ? BeaconIdentifier.fromJSON(object.beacon) : undefined,
    };
  },

  toJSON(message: InitialiseSessionRequest_BeaconBasedProviderClaimRequest): unknown {
    const obj: any = {};
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.info !== undefined) {
      obj.info = ProviderClaimInfo.toJSON(message.info);
    }
    if (message.ownerProof !== undefined) {
      obj.ownerProof = InitialiseSessionRequest_ClaimOwner.toJSON(message.ownerProof);
    }
    if (message.beacon !== undefined) {
      obj.beacon = BeaconIdentifier.toJSON(message.beacon);
    }
    return obj;
  },

  create(
    base?: DeepPartial<InitialiseSessionRequest_BeaconBasedProviderClaimRequest>,
  ): InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
    return InitialiseSessionRequest_BeaconBasedProviderClaimRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<InitialiseSessionRequest_BeaconBasedProviderClaimRequest>,
  ): InitialiseSessionRequest_BeaconBasedProviderClaimRequest {
    const message = createBaseInitialiseSessionRequest_BeaconBasedProviderClaimRequest();
    message.epoch = object.epoch ?? 0;
    message.timestampS = object.timestampS ?? 0;
    message.info = (object.info !== undefined && object.info !== null)
      ? ProviderClaimInfo.fromPartial(object.info)
      : undefined;
    message.ownerProof = (object.ownerProof !== undefined && object.ownerProof !== null)
      ? InitialiseSessionRequest_ClaimOwner.fromPartial(object.ownerProof)
      : undefined;
    message.beacon = (object.beacon !== undefined && object.beacon !== null)
      ? BeaconIdentifier.fromPartial(object.beacon)
      : undefined;
    return message;
  },
};

function createBaseInitialiseSessionRequest_ClaimOwner(): InitialiseSessionRequest_ClaimOwner {
  return { address: "", signature: new Uint8Array(0) };
}

export const InitialiseSessionRequest_ClaimOwner = {
  encode(message: InitialiseSessionRequest_ClaimOwner, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitialiseSessionRequest_ClaimOwner {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialiseSessionRequest_ClaimOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialiseSessionRequest_ClaimOwner {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: InitialiseSessionRequest_ClaimOwner): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<InitialiseSessionRequest_ClaimOwner>): InitialiseSessionRequest_ClaimOwner {
    return InitialiseSessionRequest_ClaimOwner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialiseSessionRequest_ClaimOwner>): InitialiseSessionRequest_ClaimOwner {
    const message = createBaseInitialiseSessionRequest_ClaimOwner();
    message.address = object.address ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitialiseSessionResponse(): InitialiseSessionResponse {
  return { sessionId: "" };
}

export const InitialiseSessionResponse = {
  encode(message: InitialiseSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitialiseSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialiseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialiseSessionResponse {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: InitialiseSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<InitialiseSessionResponse>): InitialiseSessionResponse {
    return InitialiseSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialiseSessionResponse>): InitialiseSessionResponse {
    const message = createBaseInitialiseSessionResponse();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBasePushToSessionRequest(): PushToSessionRequest {
  return { sessionId: "", messages: [] };
}

export const PushToSessionRequest = {
  encode(message: PushToSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    for (const v of message.messages) {
      TLSPacket.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PushToSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushToSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(TLSPacket.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushToSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => TLSPacket.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PushToSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => TLSPacket.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PushToSessionRequest>): PushToSessionRequest {
    return PushToSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushToSessionRequest>): PushToSessionRequest {
    const message = createBasePushToSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.messages = object.messages?.map((e) => TLSPacket.fromPartial(e)) || [];
    return message;
  },
};

function createBasePushToSessionResponse(): PushToSessionResponse {
  return { index: 0 };
}

export const PushToSessionResponse = {
  encode(message: PushToSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PushToSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushToSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushToSessionResponse {
    return { index: isSet(object.index) ? globalThis.Number(object.index) : 0 };
  },

  toJSON(message: PushToSessionResponse): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<PushToSessionResponse>): PushToSessionResponse {
    return PushToSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushToSessionResponse>): PushToSessionResponse {
    const message = createBasePushToSessionResponse();
    message.index = object.index ?? 0;
    return message;
  },
};

function createBasePullFromSessionRequest(): PullFromSessionRequest {
  return { sessionId: "", version: 0 };
}

export const PullFromSessionRequest = {
  encode(message: PullFromSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PullFromSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullFromSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullFromSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      version: isSet(object.version) ? witnessVersionFromJSON(object.version) : 0,
    };
  },

  toJSON(message: PullFromSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.version !== 0) {
      obj.version = witnessVersionToJSON(message.version);
    }
    return obj;
  },

  create(base?: DeepPartial<PullFromSessionRequest>): PullFromSessionRequest {
    return PullFromSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullFromSessionRequest>): PullFromSessionRequest {
    const message = createBasePullFromSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.version = object.version ?? 0;
    return message;
  },
};

function createBasePullFromSessionResponse(): PullFromSessionResponse {
  return { message: undefined, index: 0 };
}

export const PullFromSessionResponse = {
  encode(message: PullFromSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== undefined) {
      TLSPacket.encode(message.message, writer.uint32(10).fork()).ldelim();
    }
    if (message.index !== 0) {
      writer.uint32(16).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PullFromSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullFromSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = TLSPacket.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullFromSessionResponse {
    return {
      message: isSet(object.message) ? TLSPacket.fromJSON(object.message) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: PullFromSessionResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = TLSPacket.toJSON(message.message);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<PullFromSessionResponse>): PullFromSessionResponse {
    return PullFromSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullFromSessionResponse>): PullFromSessionResponse {
    const message = createBasePullFromSessionResponse();
    message.message = (object.message !== undefined && object.message !== null)
      ? TLSPacket.fromPartial(object.message)
      : undefined;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseCancelSessionRequest(): CancelSessionRequest {
  return { sessionId: "" };
}

export const CancelSessionRequest = {
  encode(message: CancelSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: CancelSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelSessionRequest>): CancelSessionRequest {
    return CancelSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelSessionRequest>): CancelSessionRequest {
    const message = createBaseCancelSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseCancelSessionResponse(): CancelSessionResponse {
  return {};
}

export const CancelSessionResponse = {
  encode(_: CancelSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CancelSessionResponse {
    return {};
  },

  toJSON(_: CancelSessionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CancelSessionResponse>): CancelSessionResponse {
    return CancelSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CancelSessionResponse>): CancelSessionResponse {
    const message = createBaseCancelSessionResponse();
    return message;
  },
};

function createBaseFinaliseSessionRequest(): FinaliseSessionRequest {
  return { sessionId: "", revealBlocks: [] };
}

export const FinaliseSessionRequest = {
  encode(message: FinaliseSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    for (const v of message.revealBlocks) {
      FinaliseSessionRequest_Block.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revealBlocks.push(FinaliseSessionRequest_Block.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      revealBlocks: globalThis.Array.isArray(object?.revealBlocks)
        ? object.revealBlocks.map((e: any) => FinaliseSessionRequest_Block.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinaliseSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.revealBlocks?.length) {
      obj.revealBlocks = message.revealBlocks.map((e) => FinaliseSessionRequest_Block.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionRequest>): FinaliseSessionRequest {
    return FinaliseSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionRequest>): FinaliseSessionRequest {
    const message = createBaseFinaliseSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.revealBlocks = object.revealBlocks?.map((e) => FinaliseSessionRequest_Block.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinaliseSessionRequest_Block(): FinaliseSessionRequest_Block {
  return { authTag: new Uint8Array(0), directReveal: undefined, zkReveal: undefined, index: 0 };
}

export const FinaliseSessionRequest_Block = {
  encode(message: FinaliseSessionRequest_Block, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.authTag.length !== 0) {
      writer.uint32(10).bytes(message.authTag);
    }
    if (message.directReveal !== undefined) {
      FinaliseSessionRequest_BlockRevealDirect.encode(message.directReveal, writer.uint32(34).fork()).ldelim();
    }
    if (message.zkReveal !== undefined) {
      FinaliseSessionRequest_BlockRevealZk.encode(message.zkReveal, writer.uint32(42).fork()).ldelim();
    }
    if (message.index !== 0) {
      writer.uint32(48).uint32(message.index);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionRequest_Block {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionRequest_Block();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.authTag = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.directReveal = FinaliseSessionRequest_BlockRevealDirect.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.zkReveal = FinaliseSessionRequest_BlockRevealZk.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.index = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionRequest_Block {
    return {
      authTag: isSet(object.authTag) ? bytesFromBase64(object.authTag) : new Uint8Array(0),
      directReveal: isSet(object.directReveal)
        ? FinaliseSessionRequest_BlockRevealDirect.fromJSON(object.directReveal)
        : undefined,
      zkReveal: isSet(object.zkReveal) ? FinaliseSessionRequest_BlockRevealZk.fromJSON(object.zkReveal) : undefined,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
    };
  },

  toJSON(message: FinaliseSessionRequest_Block): unknown {
    const obj: any = {};
    if (message.authTag.length !== 0) {
      obj.authTag = base64FromBytes(message.authTag);
    }
    if (message.directReveal !== undefined) {
      obj.directReveal = FinaliseSessionRequest_BlockRevealDirect.toJSON(message.directReveal);
    }
    if (message.zkReveal !== undefined) {
      obj.zkReveal = FinaliseSessionRequest_BlockRevealZk.toJSON(message.zkReveal);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionRequest_Block>): FinaliseSessionRequest_Block {
    return FinaliseSessionRequest_Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionRequest_Block>): FinaliseSessionRequest_Block {
    const message = createBaseFinaliseSessionRequest_Block();
    message.authTag = object.authTag ?? new Uint8Array(0);
    message.directReveal = (object.directReveal !== undefined && object.directReveal !== null)
      ? FinaliseSessionRequest_BlockRevealDirect.fromPartial(object.directReveal)
      : undefined;
    message.zkReveal = (object.zkReveal !== undefined && object.zkReveal !== null)
      ? FinaliseSessionRequest_BlockRevealZk.fromPartial(object.zkReveal)
      : undefined;
    message.index = object.index ?? 0;
    return message;
  },
};

function createBaseFinaliseSessionRequest_BlockRevealDirect(): FinaliseSessionRequest_BlockRevealDirect {
  return { key: new Uint8Array(0), iv: new Uint8Array(0), recordNumber: 0 };
}

export const FinaliseSessionRequest_BlockRevealDirect = {
  encode(message: FinaliseSessionRequest_BlockRevealDirect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      writer.uint32(24).uint32(message.recordNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionRequest_BlockRevealDirect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionRequest_BlockRevealDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recordNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionRequest_BlockRevealDirect {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      recordNumber: isSet(object.recordNumber) ? globalThis.Number(object.recordNumber) : 0,
    };
  },

  toJSON(message: FinaliseSessionRequest_BlockRevealDirect): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      obj.recordNumber = Math.round(message.recordNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionRequest_BlockRevealDirect>): FinaliseSessionRequest_BlockRevealDirect {
    return FinaliseSessionRequest_BlockRevealDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionRequest_BlockRevealDirect>): FinaliseSessionRequest_BlockRevealDirect {
    const message = createBaseFinaliseSessionRequest_BlockRevealDirect();
    message.key = object.key ?? new Uint8Array(0);
    message.iv = object.iv ?? new Uint8Array(0);
    message.recordNumber = object.recordNumber ?? 0;
    return message;
  },
};

function createBaseFinaliseSessionRequest_BlockRevealZk(): FinaliseSessionRequest_BlockRevealZk {
  return { proofs: [] };
}

export const FinaliseSessionRequest_BlockRevealZk = {
  encode(message: FinaliseSessionRequest_BlockRevealZk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proofs) {
      FinaliseSessionRequest_ZKProof.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionRequest_BlockRevealZk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionRequest_BlockRevealZk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofs.push(FinaliseSessionRequest_ZKProof.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionRequest_BlockRevealZk {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => FinaliseSessionRequest_ZKProof.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FinaliseSessionRequest_BlockRevealZk): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => FinaliseSessionRequest_ZKProof.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionRequest_BlockRevealZk>): FinaliseSessionRequest_BlockRevealZk {
    return FinaliseSessionRequest_BlockRevealZk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionRequest_BlockRevealZk>): FinaliseSessionRequest_BlockRevealZk {
    const message = createBaseFinaliseSessionRequest_BlockRevealZk();
    message.proofs = object.proofs?.map((e) => FinaliseSessionRequest_ZKProof.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFinaliseSessionRequest_ZKProof(): FinaliseSessionRequest_ZKProof {
  return {
    proofJson: "",
    decryptedRedactedCiphertext: new Uint8Array(0),
    redactedPlaintext: new Uint8Array(0),
    startIdx: 0,
  };
}

export const FinaliseSessionRequest_ZKProof = {
  encode(message: FinaliseSessionRequest_ZKProof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proofJson !== "") {
      writer.uint32(10).string(message.proofJson);
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      writer.uint32(18).bytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      writer.uint32(26).bytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      writer.uint32(32).uint32(message.startIdx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionRequest_ZKProof {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionRequest_ZKProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofJson = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.decryptedRedactedCiphertext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.redactedPlaintext = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startIdx = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionRequest_ZKProof {
    return {
      proofJson: isSet(object.proofJson) ? globalThis.String(object.proofJson) : "",
      decryptedRedactedCiphertext: isSet(object.decryptedRedactedCiphertext)
        ? bytesFromBase64(object.decryptedRedactedCiphertext)
        : new Uint8Array(0),
      redactedPlaintext: isSet(object.redactedPlaintext)
        ? bytesFromBase64(object.redactedPlaintext)
        : new Uint8Array(0),
      startIdx: isSet(object.startIdx) ? globalThis.Number(object.startIdx) : 0,
    };
  },

  toJSON(message: FinaliseSessionRequest_ZKProof): unknown {
    const obj: any = {};
    if (message.proofJson !== "") {
      obj.proofJson = message.proofJson;
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      obj.decryptedRedactedCiphertext = base64FromBytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      obj.redactedPlaintext = base64FromBytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      obj.startIdx = Math.round(message.startIdx);
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionRequest_ZKProof>): FinaliseSessionRequest_ZKProof {
    return FinaliseSessionRequest_ZKProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionRequest_ZKProof>): FinaliseSessionRequest_ZKProof {
    const message = createBaseFinaliseSessionRequest_ZKProof();
    message.proofJson = object.proofJson ?? "";
    message.decryptedRedactedCiphertext = object.decryptedRedactedCiphertext ?? new Uint8Array(0);
    message.redactedPlaintext = object.redactedPlaintext ?? new Uint8Array(0);
    message.startIdx = object.startIdx ?? 0;
    return message;
  },
};

function createBaseFinaliseSessionResponse(): FinaliseSessionResponse {
  return { receipt: undefined, claimData: undefined, signature: new Uint8Array(0) };
}

export const FinaliseSessionResponse = {
  encode(message: FinaliseSessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.receipt !== undefined) {
      TLSReceipt.encode(message.receipt, writer.uint32(10).fork()).ldelim();
    }
    if (message.claimData !== undefined) {
      ProviderClaimData.encode(message.claimData, writer.uint32(18).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FinaliseSessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinaliseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receipt = TLSReceipt.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimData = ProviderClaimData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinaliseSessionResponse {
    return {
      receipt: isSet(object.receipt) ? TLSReceipt.fromJSON(object.receipt) : undefined,
      claimData: isSet(object.claimData) ? ProviderClaimData.fromJSON(object.claimData) : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: FinaliseSessionResponse): unknown {
    const obj: any = {};
    if (message.receipt !== undefined) {
      obj.receipt = TLSReceipt.toJSON(message.receipt);
    }
    if (message.claimData !== undefined) {
      obj.claimData = ProviderClaimData.toJSON(message.claimData);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<FinaliseSessionResponse>): FinaliseSessionResponse {
    return FinaliseSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinaliseSessionResponse>): FinaliseSessionResponse {
    const message = createBaseFinaliseSessionResponse();
    message.receipt = (object.receipt !== undefined && object.receipt !== null)
      ? TLSReceipt.fromPartial(object.receipt)
      : undefined;
    message.claimData = (object.claimData !== undefined && object.claimData !== null)
      ? ProviderClaimData.fromPartial(object.claimData)
      : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWitnessErrorData(): WitnessErrorData {
  return { code: 0, message: "", data: "" };
}

export const WitnessErrorData = {
  encode(message: WitnessErrorData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WitnessErrorData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitnessErrorData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WitnessErrorData {
    return {
      code: isSet(object.code) ? witnessErrorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: WitnessErrorData): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = witnessErrorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create(base?: DeepPartial<WitnessErrorData>): WitnessErrorData {
    return WitnessErrorData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WitnessErrorData>): WitnessErrorData {
    const message = createBaseWitnessErrorData();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCreateTunnelRequest(): CreateTunnelRequest {
  return { id: 0, host: "", port: 0, geoLocation: "", initialMessage: new Uint8Array(0) };
}

export const CreateTunnelRequest = {
  encode(message: CreateTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    if (message.geoLocation !== "") {
      writer.uint32(34).string(message.geoLocation);
    }
    if (message.initialMessage.length !== 0) {
      writer.uint32(42).bytes(message.initialMessage);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.port = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.geoLocation = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.initialMessage = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTunnelRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
      initialMessage: isSet(object.initialMessage) ? bytesFromBase64(object.initialMessage) : new Uint8Array(0),
    };
  },

  toJSON(message: CreateTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.geoLocation !== "") {
      obj.geoLocation = message.geoLocation;
    }
    if (message.initialMessage.length !== 0) {
      obj.initialMessage = base64FromBytes(message.initialMessage);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    return CreateTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    const message = createBaseCreateTunnelRequest();
    message.id = object.id ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.geoLocation = object.geoLocation ?? "";
    message.initialMessage = object.initialMessage ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDisconnectTunnelRequest(): DisconnectTunnelRequest {
  return { id: 0 };
}

export const DisconnectTunnelRequest = {
  encode(message: DisconnectTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisconnectTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnectTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisconnectTunnelRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DisconnectTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    return DisconnectTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    const message = createBaseDisconnectTunnelRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseTunnelMessage(): TunnelMessage {
  return { tunnelId: 0, message: new Uint8Array(0) };
}

export const TunnelMessage = {
  encode(message: TunnelMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TunnelMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelMessage {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
    };
  },

  toJSON(message: TunnelMessage): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelMessage>): TunnelMessage {
    return TunnelMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelMessage>): TunnelMessage {
    const message = createBaseTunnelMessage();
    message.tunnelId = object.tunnelId ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTunnelDisconnectEvent(): TunnelDisconnectEvent {
  return { tunnelId: 0, error: undefined };
}

export const TunnelDisconnectEvent = {
  encode(message: TunnelDisconnectEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.error !== undefined) {
      WitnessErrorData.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TunnelDisconnectEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelDisconnectEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = WitnessErrorData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelDisconnectEvent {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      error: isSet(object.error) ? WitnessErrorData.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: TunnelDisconnectEvent): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.error !== undefined) {
      obj.error = WitnessErrorData.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    return TunnelDisconnectEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    const message = createBaseTunnelDisconnectEvent();
    message.tunnelId = object.tunnelId ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? WitnessErrorData.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal(): MessageReveal {
  return { directReveal: undefined, zkReveal: undefined };
}

export const MessageReveal = {
  encode(message: MessageReveal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.directReveal !== undefined) {
      MessageReveal_MessageRevealDirect.encode(message.directReveal, writer.uint32(10).fork()).ldelim();
    }
    if (message.zkReveal !== undefined) {
      MessageReveal_MessageRevealZk.encode(message.zkReveal, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.directReveal = MessageReveal_MessageRevealDirect.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zkReveal = MessageReveal_MessageRevealZk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal {
    return {
      directReveal: isSet(object.directReveal)
        ? MessageReveal_MessageRevealDirect.fromJSON(object.directReveal)
        : undefined,
      zkReveal: isSet(object.zkReveal) ? MessageReveal_MessageRevealZk.fromJSON(object.zkReveal) : undefined,
    };
  },

  toJSON(message: MessageReveal): unknown {
    const obj: any = {};
    if (message.directReveal !== undefined) {
      obj.directReveal = MessageReveal_MessageRevealDirect.toJSON(message.directReveal);
    }
    if (message.zkReveal !== undefined) {
      obj.zkReveal = MessageReveal_MessageRevealZk.toJSON(message.zkReveal);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal>): MessageReveal {
    return MessageReveal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal>): MessageReveal {
    const message = createBaseMessageReveal();
    message.directReveal = (object.directReveal !== undefined && object.directReveal !== null)
      ? MessageReveal_MessageRevealDirect.fromPartial(object.directReveal)
      : undefined;
    message.zkReveal = (object.zkReveal !== undefined && object.zkReveal !== null)
      ? MessageReveal_MessageRevealZk.fromPartial(object.zkReveal)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealDirect(): MessageReveal_MessageRevealDirect {
  return { key: new Uint8Array(0), iv: new Uint8Array(0), recordNumber: 0 };
}

export const MessageReveal_MessageRevealDirect = {
  encode(message: MessageReveal_MessageRevealDirect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      writer.uint32(24).uint32(message.recordNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_MessageRevealDirect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recordNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealDirect {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      recordNumber: isSet(object.recordNumber) ? globalThis.Number(object.recordNumber) : 0,
    };
  },

  toJSON(message: MessageReveal_MessageRevealDirect): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      obj.recordNumber = Math.round(message.recordNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    return MessageReveal_MessageRevealDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    const message = createBaseMessageReveal_MessageRevealDirect();
    message.key = object.key ?? new Uint8Array(0);
    message.iv = object.iv ?? new Uint8Array(0);
    message.recordNumber = object.recordNumber ?? 0;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealZk(): MessageReveal_MessageRevealZk {
  return { proofs: [] };
}

export const MessageReveal_MessageRevealZk = {
  encode(message: MessageReveal_MessageRevealZk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proofs) {
      MessageReveal_ZKProof.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_MessageRevealZk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealZk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofs.push(MessageReveal_ZKProof.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealZk {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => MessageReveal_ZKProof.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageReveal_MessageRevealZk): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => MessageReveal_ZKProof.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    return MessageReveal_MessageRevealZk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    const message = createBaseMessageReveal_MessageRevealZk();
    message.proofs = object.proofs?.map((e) => MessageReveal_ZKProof.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageReveal_ZKProof(): MessageReveal_ZKProof {
  return {
    proofJson: "",
    decryptedRedactedCiphertext: new Uint8Array(0),
    redactedPlaintext: new Uint8Array(0),
    startIdx: 0,
  };
}

export const MessageReveal_ZKProof = {
  encode(message: MessageReveal_ZKProof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proofJson !== "") {
      writer.uint32(10).string(message.proofJson);
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      writer.uint32(18).bytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      writer.uint32(26).bytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      writer.uint32(32).uint32(message.startIdx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_ZKProof {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_ZKProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofJson = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.decryptedRedactedCiphertext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.redactedPlaintext = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startIdx = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_ZKProof {
    return {
      proofJson: isSet(object.proofJson) ? globalThis.String(object.proofJson) : "",
      decryptedRedactedCiphertext: isSet(object.decryptedRedactedCiphertext)
        ? bytesFromBase64(object.decryptedRedactedCiphertext)
        : new Uint8Array(0),
      redactedPlaintext: isSet(object.redactedPlaintext)
        ? bytesFromBase64(object.redactedPlaintext)
        : new Uint8Array(0),
      startIdx: isSet(object.startIdx) ? globalThis.Number(object.startIdx) : 0,
    };
  },

  toJSON(message: MessageReveal_ZKProof): unknown {
    const obj: any = {};
    if (message.proofJson !== "") {
      obj.proofJson = message.proofJson;
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      obj.decryptedRedactedCiphertext = base64FromBytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      obj.redactedPlaintext = base64FromBytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      obj.startIdx = Math.round(message.startIdx);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    return MessageReveal_ZKProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    const message = createBaseMessageReveal_ZKProof();
    message.proofJson = object.proofJson ?? "";
    message.decryptedRedactedCiphertext = object.decryptedRedactedCiphertext ?? new Uint8Array(0);
    message.redactedPlaintext = object.redactedPlaintext ?? new Uint8Array(0);
    message.startIdx = object.startIdx ?? 0;
    return message;
  },
};

function createBaseClaimTunnelRequest(): ClaimTunnelRequest {
  return { request: undefined, timestampS: 0, info: undefined, transcript: [], signatures: undefined };
}

export const ClaimTunnelRequest = {
  encode(message: ClaimTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined) {
      CreateTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.timestampS !== 0) {
      writer.uint32(16).uint32(message.timestampS);
    }
    if (message.info !== undefined) {
      ProviderClaimInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.transcript) {
      ClaimTunnelRequest_TranscriptMessage.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelRequest_Signatures.encode(message.signatures, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.info = ProviderClaimInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transcript.push(ClaimTunnelRequest_TranscriptMessage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signatures = ClaimTunnelRequest_Signatures.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest {
    return {
      request: isSet(object.request) ? CreateTunnelRequest.fromJSON(object.request) : undefined,
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      info: isSet(object.info) ? ProviderClaimInfo.fromJSON(object.info) : undefined,
      transcript: globalThis.Array.isArray(object?.transcript)
        ? object.transcript.map((e: any) => ClaimTunnelRequest_TranscriptMessage.fromJSON(e))
        : [],
      signatures: isSet(object.signatures) ? ClaimTunnelRequest_Signatures.fromJSON(object.signatures) : undefined,
    };
  },

  toJSON(message: ClaimTunnelRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = CreateTunnelRequest.toJSON(message.request);
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.info !== undefined) {
      obj.info = ProviderClaimInfo.toJSON(message.info);
    }
    if (message.transcript?.length) {
      obj.transcript = message.transcript.map((e) => ClaimTunnelRequest_TranscriptMessage.toJSON(e));
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelRequest_Signatures.toJSON(message.signatures);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    return ClaimTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    const message = createBaseClaimTunnelRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? CreateTunnelRequest.fromPartial(object.request)
      : undefined;
    message.timestampS = object.timestampS ?? 0;
    message.info = (object.info !== undefined && object.info !== null)
      ? ProviderClaimInfo.fromPartial(object.info)
      : undefined;
    message.transcript = object.transcript?.map((e) => ClaimTunnelRequest_TranscriptMessage.fromPartial(e)) || [];
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelRequest_Signatures.fromPartial(object.signatures)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelRequest_Signatures(): ClaimTunnelRequest_Signatures {
  return { requestSignature: new Uint8Array(0) };
}

export const ClaimTunnelRequest_Signatures = {
  encode(message: ClaimTunnelRequest_Signatures, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestSignature.length !== 0) {
      writer.uint32(10).bytes(message.requestSignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest_Signatures {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestSignature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_Signatures {
    return {
      requestSignature: isSet(object.requestSignature) ? bytesFromBase64(object.requestSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelRequest_Signatures): unknown {
    const obj: any = {};
    if (message.requestSignature.length !== 0) {
      obj.requestSignature = base64FromBytes(message.requestSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    return ClaimTunnelRequest_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    const message = createBaseClaimTunnelRequest_Signatures();
    message.requestSignature = object.requestSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTunnelRequest_TranscriptMessage(): ClaimTunnelRequest_TranscriptMessage {
  return { sender: 0, message: new Uint8Array(0), reveal: undefined };
}

export const ClaimTunnelRequest_TranscriptMessage = {
  encode(message: ClaimTunnelRequest_TranscriptMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== 0) {
      writer.uint32(8).int32(message.sender);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    if (message.reveal !== undefined) {
      MessageReveal.encode(message.reveal, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest_TranscriptMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sender = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reveal = MessageReveal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_TranscriptMessage {
    return {
      sender: isSet(object.sender) ? transcriptMessageSenderTypeFromJSON(object.sender) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      reveal: isSet(object.reveal) ? MessageReveal.fromJSON(object.reveal) : undefined,
    };
  },

  toJSON(message: ClaimTunnelRequest_TranscriptMessage): unknown {
    const obj: any = {};
    if (message.sender !== 0) {
      obj.sender = transcriptMessageSenderTypeToJSON(message.sender);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.reveal !== undefined) {
      obj.reveal = MessageReveal.toJSON(message.reveal);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    return ClaimTunnelRequest_TranscriptMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    message.sender = object.sender ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    message.reveal = (object.reveal !== undefined && object.reveal !== null)
      ? MessageReveal.fromPartial(object.reveal)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse(): ClaimTunnelResponse {
  return { request: undefined, claim: undefined, error: undefined, signatures: undefined };
}

export const ClaimTunnelResponse = {
  encode(message: ClaimTunnelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined) {
      ClaimTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.claim !== undefined) {
      ProviderClaimData.encode(message.claim, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      WitnessErrorData.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelResponse_Signatures.encode(message.signatures, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claim = ProviderClaimData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures = ClaimTunnelResponse_Signatures.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse {
    return {
      request: isSet(object.request) ? ClaimTunnelRequest.fromJSON(object.request) : undefined,
      claim: isSet(object.claim) ? ProviderClaimData.fromJSON(object.claim) : undefined,
      error: isSet(object.error) ? WitnessErrorData.fromJSON(object.error) : undefined,
      signatures: isSet(object.signatures) ? ClaimTunnelResponse_Signatures.fromJSON(object.signatures) : undefined,
    };
  },

  toJSON(message: ClaimTunnelResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ClaimTunnelRequest.toJSON(message.request);
    }
    if (message.claim !== undefined) {
      obj.claim = ProviderClaimData.toJSON(message.claim);
    }
    if (message.error !== undefined) {
      obj.error = WitnessErrorData.toJSON(message.error);
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelResponse_Signatures.toJSON(message.signatures);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    return ClaimTunnelResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    const message = createBaseClaimTunnelResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? ClaimTunnelRequest.fromPartial(object.request)
      : undefined;
    message.claim = (object.claim !== undefined && object.claim !== null)
      ? ProviderClaimData.fromPartial(object.claim)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? WitnessErrorData.fromPartial(object.error)
      : undefined;
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelResponse_Signatures.fromPartial(object.signatures)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse_Signatures(): ClaimTunnelResponse_Signatures {
  return { claimSignature: new Uint8Array(0), resultSignature: new Uint8Array(0) };
}

export const ClaimTunnelResponse_Signatures = {
  encode(message: ClaimTunnelResponse_Signatures, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.claimSignature.length !== 0) {
      writer.uint32(10).bytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      writer.uint32(18).bytes(message.resultSignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelResponse_Signatures {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.claimSignature = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resultSignature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse_Signatures {
    return {
      claimSignature: isSet(object.claimSignature) ? bytesFromBase64(object.claimSignature) : new Uint8Array(0),
      resultSignature: isSet(object.resultSignature) ? bytesFromBase64(object.resultSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelResponse_Signatures): unknown {
    const obj: any = {};
    if (message.claimSignature.length !== 0) {
      obj.claimSignature = base64FromBytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      obj.resultSignature = base64FromBytes(message.resultSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    return ClaimTunnelResponse_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    const message = createBaseClaimTunnelResponse_Signatures();
    message.claimSignature = object.claimSignature ?? new Uint8Array(0);
    message.resultSignature = object.resultSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitRequest(): InitRequest {
  return { userId: "", clientVersion: 0, signatureType: 0 };
}

export const InitRequest = {
  encode(message: InitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.clientVersion !== 0) {
      writer.uint32(16).int32(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      writer.uint32(24).int32(message.signatureType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      clientVersion: isSet(object.clientVersion) ? witnessVersionFromJSON(object.clientVersion) : 0,
      signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0,
    };
  },

  toJSON(message: InitRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.clientVersion !== 0) {
      obj.clientVersion = witnessVersionToJSON(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
    }
    return obj;
  },

  create(base?: DeepPartial<InitRequest>): InitRequest {
    return InitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitRequest>): InitRequest {
    const message = createBaseInitRequest();
    message.userId = object.userId ?? "";
    message.clientVersion = object.clientVersion ?? 0;
    message.signatureType = object.signatureType ?? 0;
    return message;
  },
};

function createBaseReclaimRPCMessage(): ReclaimRPCMessage {
  return {
    id: 0,
    initResponse: undefined,
    connectionTerminationAlert: undefined,
    requestError: undefined,
    createTunnelRequest: undefined,
    createTunnelResponse: undefined,
    disconnectTunnelRequest: undefined,
    disconnectTunnelResponse: undefined,
    tunnelMessage: undefined,
    tunnelDisconnectEvent: undefined,
    claimTunnelRequest: undefined,
    claimTunnelResponse: undefined,
  };
}

export const ReclaimRPCMessage = {
  encode(message: ReclaimRPCMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.initResponse !== undefined) {
      Empty.encode(message.initResponse, writer.uint32(18).fork()).ldelim();
    }
    if (message.connectionTerminationAlert !== undefined) {
      WitnessErrorData.encode(message.connectionTerminationAlert, writer.uint32(26).fork()).ldelim();
    }
    if (message.requestError !== undefined) {
      WitnessErrorData.encode(message.requestError, writer.uint32(34).fork()).ldelim();
    }
    if (message.createTunnelRequest !== undefined) {
      CreateTunnelRequest.encode(message.createTunnelRequest, writer.uint32(42).fork()).ldelim();
    }
    if (message.createTunnelResponse !== undefined) {
      Empty.encode(message.createTunnelResponse, writer.uint32(50).fork()).ldelim();
    }
    if (message.disconnectTunnelRequest !== undefined) {
      DisconnectTunnelRequest.encode(message.disconnectTunnelRequest, writer.uint32(58).fork()).ldelim();
    }
    if (message.disconnectTunnelResponse !== undefined) {
      Empty.encode(message.disconnectTunnelResponse, writer.uint32(66).fork()).ldelim();
    }
    if (message.tunnelMessage !== undefined) {
      TunnelMessage.encode(message.tunnelMessage, writer.uint32(74).fork()).ldelim();
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      TunnelDisconnectEvent.encode(message.tunnelDisconnectEvent, writer.uint32(82).fork()).ldelim();
    }
    if (message.claimTunnelRequest !== undefined) {
      ClaimTunnelRequest.encode(message.claimTunnelRequest, writer.uint32(90).fork()).ldelim();
    }
    if (message.claimTunnelResponse !== undefined) {
      ClaimTunnelResponse.encode(message.claimTunnelResponse, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReclaimRPCMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReclaimRPCMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connectionTerminationAlert = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestError = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTunnelRequest = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.disconnectTunnelRequest = DisconnectTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.disconnectTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.tunnelMessage = TunnelMessage.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tunnelDisconnectEvent = TunnelDisconnectEvent.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.claimTunnelRequest = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.claimTunnelResponse = ClaimTunnelResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReclaimRPCMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      initResponse: isSet(object.initResponse) ? Empty.fromJSON(object.initResponse) : undefined,
      connectionTerminationAlert: isSet(object.connectionTerminationAlert)
        ? WitnessErrorData.fromJSON(object.connectionTerminationAlert)
        : undefined,
      requestError: isSet(object.requestError) ? WitnessErrorData.fromJSON(object.requestError) : undefined,
      createTunnelRequest: isSet(object.createTunnelRequest)
        ? CreateTunnelRequest.fromJSON(object.createTunnelRequest)
        : undefined,
      createTunnelResponse: isSet(object.createTunnelResponse)
        ? Empty.fromJSON(object.createTunnelResponse)
        : undefined,
      disconnectTunnelRequest: isSet(object.disconnectTunnelRequest)
        ? DisconnectTunnelRequest.fromJSON(object.disconnectTunnelRequest)
        : undefined,
      disconnectTunnelResponse: isSet(object.disconnectTunnelResponse)
        ? Empty.fromJSON(object.disconnectTunnelResponse)
        : undefined,
      tunnelMessage: isSet(object.tunnelMessage) ? TunnelMessage.fromJSON(object.tunnelMessage) : undefined,
      tunnelDisconnectEvent: isSet(object.tunnelDisconnectEvent)
        ? TunnelDisconnectEvent.fromJSON(object.tunnelDisconnectEvent)
        : undefined,
      claimTunnelRequest: isSet(object.claimTunnelRequest)
        ? ClaimTunnelRequest.fromJSON(object.claimTunnelRequest)
        : undefined,
      claimTunnelResponse: isSet(object.claimTunnelResponse)
        ? ClaimTunnelResponse.fromJSON(object.claimTunnelResponse)
        : undefined,
    };
  },

  toJSON(message: ReclaimRPCMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.initResponse !== undefined) {
      obj.initResponse = Empty.toJSON(message.initResponse);
    }
    if (message.connectionTerminationAlert !== undefined) {
      obj.connectionTerminationAlert = WitnessErrorData.toJSON(message.connectionTerminationAlert);
    }
    if (message.requestError !== undefined) {
      obj.requestError = WitnessErrorData.toJSON(message.requestError);
    }
    if (message.createTunnelRequest !== undefined) {
      obj.createTunnelRequest = CreateTunnelRequest.toJSON(message.createTunnelRequest);
    }
    if (message.createTunnelResponse !== undefined) {
      obj.createTunnelResponse = Empty.toJSON(message.createTunnelResponse);
    }
    if (message.disconnectTunnelRequest !== undefined) {
      obj.disconnectTunnelRequest = DisconnectTunnelRequest.toJSON(message.disconnectTunnelRequest);
    }
    if (message.disconnectTunnelResponse !== undefined) {
      obj.disconnectTunnelResponse = Empty.toJSON(message.disconnectTunnelResponse);
    }
    if (message.tunnelMessage !== undefined) {
      obj.tunnelMessage = TunnelMessage.toJSON(message.tunnelMessage);
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      obj.tunnelDisconnectEvent = TunnelDisconnectEvent.toJSON(message.tunnelDisconnectEvent);
    }
    if (message.claimTunnelRequest !== undefined) {
      obj.claimTunnelRequest = ClaimTunnelRequest.toJSON(message.claimTunnelRequest);
    }
    if (message.claimTunnelResponse !== undefined) {
      obj.claimTunnelResponse = ClaimTunnelResponse.toJSON(message.claimTunnelResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<ReclaimRPCMessage>): ReclaimRPCMessage {
    return ReclaimRPCMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReclaimRPCMessage>): ReclaimRPCMessage {
    const message = createBaseReclaimRPCMessage();
    message.id = object.id ?? 0;
    message.initResponse = (object.initResponse !== undefined && object.initResponse !== null)
      ? Empty.fromPartial(object.initResponse)
      : undefined;
    message.connectionTerminationAlert =
      (object.connectionTerminationAlert !== undefined && object.connectionTerminationAlert !== null)
        ? WitnessErrorData.fromPartial(object.connectionTerminationAlert)
        : undefined;
    message.requestError = (object.requestError !== undefined && object.requestError !== null)
      ? WitnessErrorData.fromPartial(object.requestError)
      : undefined;
    message.createTunnelRequest = (object.createTunnelRequest !== undefined && object.createTunnelRequest !== null)
      ? CreateTunnelRequest.fromPartial(object.createTunnelRequest)
      : undefined;
    message.createTunnelResponse = (object.createTunnelResponse !== undefined && object.createTunnelResponse !== null)
      ? Empty.fromPartial(object.createTunnelResponse)
      : undefined;
    message.disconnectTunnelRequest =
      (object.disconnectTunnelRequest !== undefined && object.disconnectTunnelRequest !== null)
        ? DisconnectTunnelRequest.fromPartial(object.disconnectTunnelRequest)
        : undefined;
    message.disconnectTunnelResponse =
      (object.disconnectTunnelResponse !== undefined && object.disconnectTunnelResponse !== null)
        ? Empty.fromPartial(object.disconnectTunnelResponse)
        : undefined;
    message.tunnelMessage = (object.tunnelMessage !== undefined && object.tunnelMessage !== null)
      ? TunnelMessage.fromPartial(object.tunnelMessage)
      : undefined;
    message.tunnelDisconnectEvent =
      (object.tunnelDisconnectEvent !== undefined && object.tunnelDisconnectEvent !== null)
        ? TunnelDisconnectEvent.fromPartial(object.tunnelDisconnectEvent)
        : undefined;
    message.claimTunnelRequest = (object.claimTunnelRequest !== undefined && object.claimTunnelRequest !== null)
      ? ClaimTunnelRequest.fromPartial(object.claimTunnelRequest)
      : undefined;
    message.claimTunnelResponse = (object.claimTunnelResponse !== undefined && object.claimTunnelResponse !== null)
      ? ClaimTunnelResponse.fromPartial(object.claimTunnelResponse)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
