// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.174.0
//   protoc               v3.21.12
// source: api.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "reclaim_witness";

export enum TranscriptMessageSenderType {
  TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN = 0,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT = 1,
  TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER = 2,
  UNRECOGNIZED = -1,
}

export function transcriptMessageSenderTypeFromJSON(object: any): TranscriptMessageSenderType {
  switch (object) {
    case 0:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN;
    case 1:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT;
    case 2:
    case "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER":
      return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TranscriptMessageSenderType.UNRECOGNIZED;
  }
}

export function transcriptMessageSenderTypeToJSON(object: TranscriptMessageSenderType): string {
  switch (object) {
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT";
    case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER:
      return "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER";
    case TranscriptMessageSenderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ServiceSignatureType {
  SERVICE_SIGNATURE_TYPE_UNKNOWN = 0,
  /**
   * SERVICE_SIGNATURE_TYPE_ETH - ETH keys & signature
   * keys: secp256k1
   * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
   */
  SERVICE_SIGNATURE_TYPE_ETH = 1,
  UNRECOGNIZED = -1,
}

export function serviceSignatureTypeFromJSON(object: any): ServiceSignatureType {
  switch (object) {
    case 0:
    case "SERVICE_SIGNATURE_TYPE_UNKNOWN":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN;
    case 1:
    case "SERVICE_SIGNATURE_TYPE_ETH":
      return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServiceSignatureType.UNRECOGNIZED;
  }
}

export function serviceSignatureTypeToJSON(object: ServiceSignatureType): string {
  switch (object) {
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN:
      return "SERVICE_SIGNATURE_TYPE_UNKNOWN";
    case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH:
      return "SERVICE_SIGNATURE_TYPE_ETH";
    case ServiceSignatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WitnessVersion {
  WITNESS_VERSION_UNKNOWN = 0,
  WITNESS_VERSION_1_0_0 = 1,
  WITNESS_VERSION_1_1_0 = 2,
  WITNESS_VERSION_2_0_0 = 3,
  UNRECOGNIZED = -1,
}

export function witnessVersionFromJSON(object: any): WitnessVersion {
  switch (object) {
    case 0:
    case "WITNESS_VERSION_UNKNOWN":
      return WitnessVersion.WITNESS_VERSION_UNKNOWN;
    case 1:
    case "WITNESS_VERSION_1_0_0":
      return WitnessVersion.WITNESS_VERSION_1_0_0;
    case 2:
    case "WITNESS_VERSION_1_1_0":
      return WitnessVersion.WITNESS_VERSION_1_1_0;
    case 3:
    case "WITNESS_VERSION_2_0_0":
      return WitnessVersion.WITNESS_VERSION_2_0_0;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WitnessVersion.UNRECOGNIZED;
  }
}

export function witnessVersionToJSON(object: WitnessVersion): string {
  switch (object) {
    case WitnessVersion.WITNESS_VERSION_UNKNOWN:
      return "WITNESS_VERSION_UNKNOWN";
    case WitnessVersion.WITNESS_VERSION_1_0_0:
      return "WITNESS_VERSION_1_0_0";
    case WitnessVersion.WITNESS_VERSION_1_1_0:
      return "WITNESS_VERSION_1_1_0";
    case WitnessVersion.WITNESS_VERSION_2_0_0:
      return "WITNESS_VERSION_2_0_0";
    case WitnessVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BeaconType {
  BEACON_TYPE_UNKNOWN = 0,
  BEACON_TYPE_SMART_CONTRACT = 1,
  BEACON_TYPE_RECLAIM_TRUSTED = 2,
  UNRECOGNIZED = -1,
}

export function beaconTypeFromJSON(object: any): BeaconType {
  switch (object) {
    case 0:
    case "BEACON_TYPE_UNKNOWN":
      return BeaconType.BEACON_TYPE_UNKNOWN;
    case 1:
    case "BEACON_TYPE_SMART_CONTRACT":
      return BeaconType.BEACON_TYPE_SMART_CONTRACT;
    case 2:
    case "BEACON_TYPE_RECLAIM_TRUSTED":
      return BeaconType.BEACON_TYPE_RECLAIM_TRUSTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BeaconType.UNRECOGNIZED;
  }
}

export function beaconTypeToJSON(object: BeaconType): string {
  switch (object) {
    case BeaconType.BEACON_TYPE_UNKNOWN:
      return "BEACON_TYPE_UNKNOWN";
    case BeaconType.BEACON_TYPE_SMART_CONTRACT:
      return "BEACON_TYPE_SMART_CONTRACT";
    case BeaconType.BEACON_TYPE_RECLAIM_TRUSTED:
      return "BEACON_TYPE_RECLAIM_TRUSTED";
    case BeaconType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WitnessErrorCode {
  /** WITNESS_ERROR_NO_ERROR - 0 should be treated as the absence of an error */
  WITNESS_ERROR_NO_ERROR = 0,
  WITNESS_ERROR_INTERNAL = 1,
  WITNESS_ERROR_BAD_REQUEST = 2,
  WITNESS_ERROR_NOT_FOUND = 3,
  WITNESS_ERROR_PROXY_ERROR = 4,
  WITNESS_ERROR_INVALID_CLAIM = 5,
  UNRECOGNIZED = -1,
}

export function witnessErrorCodeFromJSON(object: any): WitnessErrorCode {
  switch (object) {
    case 0:
    case "WITNESS_ERROR_NO_ERROR":
      return WitnessErrorCode.WITNESS_ERROR_NO_ERROR;
    case 1:
    case "WITNESS_ERROR_INTERNAL":
      return WitnessErrorCode.WITNESS_ERROR_INTERNAL;
    case 2:
    case "WITNESS_ERROR_BAD_REQUEST":
      return WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST;
    case 3:
    case "WITNESS_ERROR_NOT_FOUND":
      return WitnessErrorCode.WITNESS_ERROR_NOT_FOUND;
    case 4:
    case "WITNESS_ERROR_PROXY_ERROR":
      return WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR;
    case 5:
    case "WITNESS_ERROR_INVALID_CLAIM":
      return WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WitnessErrorCode.UNRECOGNIZED;
  }
}

export function witnessErrorCodeToJSON(object: WitnessErrorCode): string {
  switch (object) {
    case WitnessErrorCode.WITNESS_ERROR_NO_ERROR:
      return "WITNESS_ERROR_NO_ERROR";
    case WitnessErrorCode.WITNESS_ERROR_INTERNAL:
      return "WITNESS_ERROR_INTERNAL";
    case WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST:
      return "WITNESS_ERROR_BAD_REQUEST";
    case WitnessErrorCode.WITNESS_ERROR_NOT_FOUND:
      return "WITNESS_ERROR_NOT_FOUND";
    case WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR:
      return "WITNESS_ERROR_PROXY_ERROR";
    case WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM:
      return "WITNESS_ERROR_INVALID_CLAIM";
    case WitnessErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ProviderClaimData {
  provider: string;
  parameters: string;
  /**
   * Owner of the claim. Must be the public key/address
   * of the signatures
   */
  owner: string;
  /** Timestamp of the claim being made. */
  timestampS: number;
  context: string;
  /**
   * identifier of the claim;
   * Hash of (provider, parameters, context)
   *
   * This is different from the claimId returned
   * from the smart contract
   */
  identifier: string;
  epoch: number;
}

export interface ProviderClaimInfo {
  provider: string;
  parameters: string;
  context: string;
}

export interface BeaconIdentifier {
  /** type of beacon */
  type: BeaconType;
  /**
   * ID of the Beacon.
   * For smart contract, it's the chain ID.
   */
  id: string;
}

export interface WitnessErrorData {
  code: WitnessErrorCode;
  message: string;
  data: string;
}

export interface CreateTunnelRequest {
  /**
   * Assign a unique ID to the client for this tunnel
   * request. This ID will be used to identify the tunnel
   * to later send messages or disconnect the tunnel.
   */
  id: number;
  host: string;
  port: number;
  /**
   * Geo location from which the request will be made.
   * Provide 2 letter ISO country code. Leave empty
   * if you don't want to use geo location.
   *
   * Geo location is implemented using an https proxy
   * eg. US, IN, GB, etc.
   */
  geoLocation: string;
}

export interface DisconnectTunnelRequest {
  id: number;
}

/** empty message */
export interface Empty {
}

export interface TunnelMessage {
  /** ID of the tunnel where this message belongs */
  tunnelId: number;
  message: Uint8Array;
}

export interface TunnelDisconnectEvent {
  tunnelId: number;
  error: WitnessErrorData | undefined;
}

export interface MessageReveal {
  /**
   * direct reveal of the block via the key & IV
   * cipher (aes, chacha) for decryption
   * selected based on `cipherSuite`
   * determined by the server hello packet
   */
  directReveal?:
    | MessageReveal_MessageRevealDirect
    | undefined;
  /** partially or fully reveal the block via a zk proof */
  zkReveal?: MessageReveal_MessageRevealZk | undefined;
}

export interface MessageReveal_MessageRevealDirect {
  /** key for the block */
  key: Uint8Array;
  /** IV for the block */
  iv: Uint8Array;
  /**
   * used to generate IV in authenticated
   * cipher suites
   */
  recordNumber: number;
}

export interface MessageReveal_MessageRevealZk {
  proofs: MessageReveal_ZKProof[];
}

export interface MessageReveal_ZKProof {
  /** JSON encoded snarkJS proof */
  proofJson: string;
  /** the decrypted ciphertext as output by the ZK proof */
  decryptedRedactedCiphertext: Uint8Array;
  /** the plaintext that is fully or partially revealed */
  redactedPlaintext: Uint8Array;
  /**
   * start of this specific ChaCha block
   * in the redactedPlaintext
   */
  startIdx: number;
}

export interface ClaimRequestData {
  provider: string;
  parameters: string;
  /**
   * Owner of the claim. Must be the public key/address
   * of the signatures
   */
  owner: string;
  /**
   * Timestamp of the claim being made.
   * Cannot be more than 10 minutes in the past
   * or in the future
   */
  timestampS: number;
  context: string;
}

export interface ClaimTunnelRequest {
  /**
   * parameters supplied to establish the tunnel
   * & connect to the end server
   */
  request:
    | CreateTunnelRequest
    | undefined;
  /** data describing the claim you want to prove */
  data:
    | ClaimRequestData
    | undefined;
  /**
   * messages from the client & server
   * in the order they were sent/received
   *
   * Attach a proof (if any) to each message
   * to reveal the contents of the message inside
   *
   * The revealed messages should support the proving
   * of the claim as defined in the provider's implementation
   */
  transcript: ClaimTunnelRequest_TranscriptMessage[];
  signatures: ClaimTunnelRequest_Signatures | undefined;
}

export interface ClaimTunnelRequest_Signatures {
  /**
   * signature of ClaimTunnelRequest
   * with empty "signatures" field
   */
  requestSignature: Uint8Array;
}

export interface ClaimTunnelRequest_TranscriptMessage {
  sender: TranscriptMessageSenderType;
  message: Uint8Array;
  reveal: MessageReveal | undefined;
}

export interface ClaimTunnelResponse {
  /** The original request that was made to claim the tunnel */
  request: ClaimTunnelRequest | undefined;
  claim?: ProviderClaimData | undefined;
  error?: WitnessErrorData | undefined;
  signatures: ClaimTunnelResponse_Signatures | undefined;
}

export interface ClaimTunnelResponse_Signatures {
  /**
   * signature of `stringifyProviderClaimData(claim)`,
   * if the claim was successful
   */
  claimSignature: Uint8Array;
  /**
   * signature of the complete ClaimTunnelResponse
   * structure with empty "signatures" field
   */
  resultSignature: Uint8Array;
}

export interface InitRequest {
  /** Witness client version */
  clientVersion: WitnessVersion;
  /** Signature type used & expected by the user */
  signatureType: ServiceSignatureType;
}

export interface RPCMessage {
  /**
   * Per connection unique RPC message ID. Either party sending a
   * duplicate ID will do nothing except confuse the other party.
   *
   * For response messages, the ID should be the same as the request
   * to which it is responding.
   */
  id: number;
  initRequest?:
    | InitRequest
    | undefined;
  /** Response to the init request. */
  initResponse?:
    | Empty
    | undefined;
  /**
   * Data representing an error in the WebSocket connection.
   * The party sending this message should close the connection
   * immediately after sending this message.
   */
  connectionTerminationAlert?:
    | WitnessErrorData
    | undefined;
  /**
   * Data representing an error in the witness's
   * request to the server. This should be sent in case
   * there was an error in processing the request.
   */
  requestError?:
    | WitnessErrorData
    | undefined;
  /** Create a tunnel to the specified host & port. */
  createTunnelRequest?: CreateTunnelRequest | undefined;
  createTunnelResponse?:
    | Empty
    | undefined;
  /** Disconnect a tunnel. */
  disconnectTunnelRequest?: DisconnectTunnelRequest | undefined;
  disconnectTunnelResponse?:
    | Empty
    | undefined;
  /**
   * Message to send through a tunnel. Client can send
   * this message to forward data to the server.
   */
  tunnelMessage?:
    | TunnelMessage
    | undefined;
  /**
   * Event indicating that a tunnel has been disconnected.
   * The client should not send any more messages through
   * this tunnel.
   */
  tunnelDisconnectEvent?:
    | TunnelDisconnectEvent
    | undefined;
  /**
   * Using the transcript of a tunnel, make a claim.
   * The tunnel must be disconnected before making a claim.
   */
  claimTunnelRequest?: ClaimTunnelRequest | undefined;
  claimTunnelResponse?: ClaimTunnelResponse | undefined;
}

export interface RPCMessages {
  messages: RPCMessage[];
}

function createBaseProviderClaimData(): ProviderClaimData {
  return { provider: "", parameters: "", owner: "", timestampS: 0, context: "", identifier: "", epoch: 0 };
}

export const ProviderClaimData = {
  encode(message: ProviderClaimData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.timestampS !== 0) {
      writer.uint32(32).uint32(message.timestampS);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    if (message.identifier !== "") {
      writer.uint32(66).string(message.identifier);
    }
    if (message.epoch !== 0) {
      writer.uint32(72).uint32(message.epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderClaimData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.identifier = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.epoch = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: ProviderClaimData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimData>): ProviderClaimData {
    return ProviderClaimData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimData>): ProviderClaimData {
    const message = createBaseProviderClaimData();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.owner = object.owner ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.context = object.context ?? "";
    message.identifier = object.identifier ?? "";
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseProviderClaimInfo(): ProviderClaimInfo {
  return { provider: "", parameters: "", context: "" };
}

export const ProviderClaimInfo = {
  encode(message: ProviderClaimInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.context !== "") {
      writer.uint32(50).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProviderClaimInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderClaimInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderClaimInfo {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ProviderClaimInfo): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    return ProviderClaimInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProviderClaimInfo>): ProviderClaimInfo {
    const message = createBaseProviderClaimInfo();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseBeaconIdentifier(): BeaconIdentifier {
  return { type: 0, id: "" };
}

export const BeaconIdentifier = {
  encode(message: BeaconIdentifier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BeaconIdentifier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBeaconIdentifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BeaconIdentifier {
    return {
      type: isSet(object.type) ? beaconTypeFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: BeaconIdentifier): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = beaconTypeToJSON(message.type);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<BeaconIdentifier>): BeaconIdentifier {
    return BeaconIdentifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BeaconIdentifier>): BeaconIdentifier {
    const message = createBaseBeaconIdentifier();
    message.type = object.type ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseWitnessErrorData(): WitnessErrorData {
  return { code: 0, message: "", data: "" };
}

export const WitnessErrorData = {
  encode(message: WitnessErrorData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.data !== "") {
      writer.uint32(26).string(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WitnessErrorData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWitnessErrorData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WitnessErrorData {
    return {
      code: isSet(object.code) ? witnessErrorCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      data: isSet(object.data) ? globalThis.String(object.data) : "",
    };
  },

  toJSON(message: WitnessErrorData): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = witnessErrorCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create(base?: DeepPartial<WitnessErrorData>): WitnessErrorData {
    return WitnessErrorData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WitnessErrorData>): WitnessErrorData {
    const message = createBaseWitnessErrorData();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCreateTunnelRequest(): CreateTunnelRequest {
  return { id: 0, host: "", port: 0, geoLocation: "" };
}

export const CreateTunnelRequest = {
  encode(message: CreateTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(24).uint32(message.port);
    }
    if (message.geoLocation !== "") {
      writer.uint32(34).string(message.geoLocation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.port = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.geoLocation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTunnelRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
    };
  },

  toJSON(message: CreateTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.geoLocation !== "") {
      obj.geoLocation = message.geoLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    return CreateTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateTunnelRequest>): CreateTunnelRequest {
    const message = createBaseCreateTunnelRequest();
    message.id = object.id ?? 0;
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.geoLocation = object.geoLocation ?? "";
    return message;
  },
};

function createBaseDisconnectTunnelRequest(): DisconnectTunnelRequest {
  return { id: 0 };
}

export const DisconnectTunnelRequest = {
  encode(message: DisconnectTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DisconnectTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnectTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisconnectTunnelRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DisconnectTunnelRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    return DisconnectTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisconnectTunnelRequest>): DisconnectTunnelRequest {
    const message = createBaseDisconnectTunnelRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseTunnelMessage(): TunnelMessage {
  return { tunnelId: 0, message: new Uint8Array(0) };
}

export const TunnelMessage = {
  encode(message: TunnelMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TunnelMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelMessage {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
    };
  },

  toJSON(message: TunnelMessage): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelMessage>): TunnelMessage {
    return TunnelMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelMessage>): TunnelMessage {
    const message = createBaseTunnelMessage();
    message.tunnelId = object.tunnelId ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTunnelDisconnectEvent(): TunnelDisconnectEvent {
  return { tunnelId: 0, error: undefined };
}

export const TunnelDisconnectEvent = {
  encode(message: TunnelDisconnectEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tunnelId !== 0) {
      writer.uint32(8).uint32(message.tunnelId);
    }
    if (message.error !== undefined) {
      WitnessErrorData.encode(message.error, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TunnelDisconnectEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunnelDisconnectEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tunnelId = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = WitnessErrorData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunnelDisconnectEvent {
    return {
      tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
      error: isSet(object.error) ? WitnessErrorData.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: TunnelDisconnectEvent): unknown {
    const obj: any = {};
    if (message.tunnelId !== 0) {
      obj.tunnelId = Math.round(message.tunnelId);
    }
    if (message.error !== undefined) {
      obj.error = WitnessErrorData.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    return TunnelDisconnectEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunnelDisconnectEvent>): TunnelDisconnectEvent {
    const message = createBaseTunnelDisconnectEvent();
    message.tunnelId = object.tunnelId ?? 0;
    message.error = (object.error !== undefined && object.error !== null)
      ? WitnessErrorData.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal(): MessageReveal {
  return { directReveal: undefined, zkReveal: undefined };
}

export const MessageReveal = {
  encode(message: MessageReveal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.directReveal !== undefined) {
      MessageReveal_MessageRevealDirect.encode(message.directReveal, writer.uint32(10).fork()).ldelim();
    }
    if (message.zkReveal !== undefined) {
      MessageReveal_MessageRevealZk.encode(message.zkReveal, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.directReveal = MessageReveal_MessageRevealDirect.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zkReveal = MessageReveal_MessageRevealZk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal {
    return {
      directReveal: isSet(object.directReveal)
        ? MessageReveal_MessageRevealDirect.fromJSON(object.directReveal)
        : undefined,
      zkReveal: isSet(object.zkReveal) ? MessageReveal_MessageRevealZk.fromJSON(object.zkReveal) : undefined,
    };
  },

  toJSON(message: MessageReveal): unknown {
    const obj: any = {};
    if (message.directReveal !== undefined) {
      obj.directReveal = MessageReveal_MessageRevealDirect.toJSON(message.directReveal);
    }
    if (message.zkReveal !== undefined) {
      obj.zkReveal = MessageReveal_MessageRevealZk.toJSON(message.zkReveal);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal>): MessageReveal {
    return MessageReveal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal>): MessageReveal {
    const message = createBaseMessageReveal();
    message.directReveal = (object.directReveal !== undefined && object.directReveal !== null)
      ? MessageReveal_MessageRevealDirect.fromPartial(object.directReveal)
      : undefined;
    message.zkReveal = (object.zkReveal !== undefined && object.zkReveal !== null)
      ? MessageReveal_MessageRevealZk.fromPartial(object.zkReveal)
      : undefined;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealDirect(): MessageReveal_MessageRevealDirect {
  return { key: new Uint8Array(0), iv: new Uint8Array(0), recordNumber: 0 };
}

export const MessageReveal_MessageRevealDirect = {
  encode(message: MessageReveal_MessageRevealDirect, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      writer.uint32(24).uint32(message.recordNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_MessageRevealDirect {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.recordNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealDirect {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      recordNumber: isSet(object.recordNumber) ? globalThis.Number(object.recordNumber) : 0,
    };
  },

  toJSON(message: MessageReveal_MessageRevealDirect): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.recordNumber !== 0) {
      obj.recordNumber = Math.round(message.recordNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    return MessageReveal_MessageRevealDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealDirect>): MessageReveal_MessageRevealDirect {
    const message = createBaseMessageReveal_MessageRevealDirect();
    message.key = object.key ?? new Uint8Array(0);
    message.iv = object.iv ?? new Uint8Array(0);
    message.recordNumber = object.recordNumber ?? 0;
    return message;
  },
};

function createBaseMessageReveal_MessageRevealZk(): MessageReveal_MessageRevealZk {
  return { proofs: [] };
}

export const MessageReveal_MessageRevealZk = {
  encode(message: MessageReveal_MessageRevealZk, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.proofs) {
      MessageReveal_ZKProof.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_MessageRevealZk {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_MessageRevealZk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofs.push(MessageReveal_ZKProof.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_MessageRevealZk {
    return {
      proofs: globalThis.Array.isArray(object?.proofs)
        ? object.proofs.map((e: any) => MessageReveal_ZKProof.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageReveal_MessageRevealZk): unknown {
    const obj: any = {};
    if (message.proofs?.length) {
      obj.proofs = message.proofs.map((e) => MessageReveal_ZKProof.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    return MessageReveal_MessageRevealZk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_MessageRevealZk>): MessageReveal_MessageRevealZk {
    const message = createBaseMessageReveal_MessageRevealZk();
    message.proofs = object.proofs?.map((e) => MessageReveal_ZKProof.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageReveal_ZKProof(): MessageReveal_ZKProof {
  return {
    proofJson: "",
    decryptedRedactedCiphertext: new Uint8Array(0),
    redactedPlaintext: new Uint8Array(0),
    startIdx: 0,
  };
}

export const MessageReveal_ZKProof = {
  encode(message: MessageReveal_ZKProof, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.proofJson !== "") {
      writer.uint32(10).string(message.proofJson);
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      writer.uint32(18).bytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      writer.uint32(26).bytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      writer.uint32(32).uint32(message.startIdx);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MessageReveal_ZKProof {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageReveal_ZKProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.proofJson = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.decryptedRedactedCiphertext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.redactedPlaintext = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startIdx = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageReveal_ZKProof {
    return {
      proofJson: isSet(object.proofJson) ? globalThis.String(object.proofJson) : "",
      decryptedRedactedCiphertext: isSet(object.decryptedRedactedCiphertext)
        ? bytesFromBase64(object.decryptedRedactedCiphertext)
        : new Uint8Array(0),
      redactedPlaintext: isSet(object.redactedPlaintext)
        ? bytesFromBase64(object.redactedPlaintext)
        : new Uint8Array(0),
      startIdx: isSet(object.startIdx) ? globalThis.Number(object.startIdx) : 0,
    };
  },

  toJSON(message: MessageReveal_ZKProof): unknown {
    const obj: any = {};
    if (message.proofJson !== "") {
      obj.proofJson = message.proofJson;
    }
    if (message.decryptedRedactedCiphertext.length !== 0) {
      obj.decryptedRedactedCiphertext = base64FromBytes(message.decryptedRedactedCiphertext);
    }
    if (message.redactedPlaintext.length !== 0) {
      obj.redactedPlaintext = base64FromBytes(message.redactedPlaintext);
    }
    if (message.startIdx !== 0) {
      obj.startIdx = Math.round(message.startIdx);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    return MessageReveal_ZKProof.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageReveal_ZKProof>): MessageReveal_ZKProof {
    const message = createBaseMessageReveal_ZKProof();
    message.proofJson = object.proofJson ?? "";
    message.decryptedRedactedCiphertext = object.decryptedRedactedCiphertext ?? new Uint8Array(0);
    message.redactedPlaintext = object.redactedPlaintext ?? new Uint8Array(0);
    message.startIdx = object.startIdx ?? 0;
    return message;
  },
};

function createBaseClaimRequestData(): ClaimRequestData {
  return { provider: "", parameters: "", owner: "", timestampS: 0, context: "" };
}

export const ClaimRequestData = {
  encode(message: ClaimRequestData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.parameters !== "") {
      writer.uint32(18).string(message.parameters);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.timestampS !== 0) {
      writer.uint32(32).uint32(message.timestampS);
    }
    if (message.context !== "") {
      writer.uint32(42).string(message.context);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimRequestData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimRequestData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameters = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timestampS = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.context = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimRequestData {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
      context: isSet(object.context) ? globalThis.String(object.context) : "",
    };
  },

  toJSON(message: ClaimRequestData): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.parameters !== "") {
      obj.parameters = message.parameters;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.timestampS !== 0) {
      obj.timestampS = Math.round(message.timestampS);
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimRequestData>): ClaimRequestData {
    return ClaimRequestData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimRequestData>): ClaimRequestData {
    const message = createBaseClaimRequestData();
    message.provider = object.provider ?? "";
    message.parameters = object.parameters ?? "";
    message.owner = object.owner ?? "";
    message.timestampS = object.timestampS ?? 0;
    message.context = object.context ?? "";
    return message;
  },
};

function createBaseClaimTunnelRequest(): ClaimTunnelRequest {
  return { request: undefined, data: undefined, transcript: [], signatures: undefined };
}

export const ClaimTunnelRequest = {
  encode(message: ClaimTunnelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined) {
      CreateTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.data !== undefined) {
      ClaimRequestData.encode(message.data, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.transcript) {
      ClaimTunnelRequest_TranscriptMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelRequest_Signatures.encode(message.signatures, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = ClaimRequestData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transcript.push(ClaimTunnelRequest_TranscriptMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures = ClaimTunnelRequest_Signatures.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest {
    return {
      request: isSet(object.request) ? CreateTunnelRequest.fromJSON(object.request) : undefined,
      data: isSet(object.data) ? ClaimRequestData.fromJSON(object.data) : undefined,
      transcript: globalThis.Array.isArray(object?.transcript)
        ? object.transcript.map((e: any) => ClaimTunnelRequest_TranscriptMessage.fromJSON(e))
        : [],
      signatures: isSet(object.signatures) ? ClaimTunnelRequest_Signatures.fromJSON(object.signatures) : undefined,
    };
  },

  toJSON(message: ClaimTunnelRequest): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = CreateTunnelRequest.toJSON(message.request);
    }
    if (message.data !== undefined) {
      obj.data = ClaimRequestData.toJSON(message.data);
    }
    if (message.transcript?.length) {
      obj.transcript = message.transcript.map((e) => ClaimTunnelRequest_TranscriptMessage.toJSON(e));
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelRequest_Signatures.toJSON(message.signatures);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    return ClaimTunnelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest>): ClaimTunnelRequest {
    const message = createBaseClaimTunnelRequest();
    message.request = (object.request !== undefined && object.request !== null)
      ? CreateTunnelRequest.fromPartial(object.request)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? ClaimRequestData.fromPartial(object.data)
      : undefined;
    message.transcript = object.transcript?.map((e) => ClaimTunnelRequest_TranscriptMessage.fromPartial(e)) || [];
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelRequest_Signatures.fromPartial(object.signatures)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelRequest_Signatures(): ClaimTunnelRequest_Signatures {
  return { requestSignature: new Uint8Array(0) };
}

export const ClaimTunnelRequest_Signatures = {
  encode(message: ClaimTunnelRequest_Signatures, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestSignature.length !== 0) {
      writer.uint32(10).bytes(message.requestSignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest_Signatures {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requestSignature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_Signatures {
    return {
      requestSignature: isSet(object.requestSignature) ? bytesFromBase64(object.requestSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelRequest_Signatures): unknown {
    const obj: any = {};
    if (message.requestSignature.length !== 0) {
      obj.requestSignature = base64FromBytes(message.requestSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    return ClaimTunnelRequest_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_Signatures>): ClaimTunnelRequest_Signatures {
    const message = createBaseClaimTunnelRequest_Signatures();
    message.requestSignature = object.requestSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseClaimTunnelRequest_TranscriptMessage(): ClaimTunnelRequest_TranscriptMessage {
  return { sender: 0, message: new Uint8Array(0), reveal: undefined };
}

export const ClaimTunnelRequest_TranscriptMessage = {
  encode(message: ClaimTunnelRequest_TranscriptMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sender !== 0) {
      writer.uint32(8).int32(message.sender);
    }
    if (message.message.length !== 0) {
      writer.uint32(18).bytes(message.message);
    }
    if (message.reveal !== undefined) {
      MessageReveal.encode(message.reveal, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelRequest_TranscriptMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sender = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reveal = MessageReveal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelRequest_TranscriptMessage {
    return {
      sender: isSet(object.sender) ? transcriptMessageSenderTypeFromJSON(object.sender) : 0,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      reveal: isSet(object.reveal) ? MessageReveal.fromJSON(object.reveal) : undefined,
    };
  },

  toJSON(message: ClaimTunnelRequest_TranscriptMessage): unknown {
    const obj: any = {};
    if (message.sender !== 0) {
      obj.sender = transcriptMessageSenderTypeToJSON(message.sender);
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.reveal !== undefined) {
      obj.reveal = MessageReveal.toJSON(message.reveal);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    return ClaimTunnelRequest_TranscriptMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelRequest_TranscriptMessage>): ClaimTunnelRequest_TranscriptMessage {
    const message = createBaseClaimTunnelRequest_TranscriptMessage();
    message.sender = object.sender ?? 0;
    message.message = object.message ?? new Uint8Array(0);
    message.reveal = (object.reveal !== undefined && object.reveal !== null)
      ? MessageReveal.fromPartial(object.reveal)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse(): ClaimTunnelResponse {
  return { request: undefined, claim: undefined, error: undefined, signatures: undefined };
}

export const ClaimTunnelResponse = {
  encode(message: ClaimTunnelResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.request !== undefined) {
      ClaimTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
    }
    if (message.claim !== undefined) {
      ProviderClaimData.encode(message.claim, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== undefined) {
      WitnessErrorData.encode(message.error, writer.uint32(26).fork()).ldelim();
    }
    if (message.signatures !== undefined) {
      ClaimTunnelResponse_Signatures.encode(message.signatures, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.request = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claim = ProviderClaimData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures = ClaimTunnelResponse_Signatures.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse {
    return {
      request: isSet(object.request) ? ClaimTunnelRequest.fromJSON(object.request) : undefined,
      claim: isSet(object.claim) ? ProviderClaimData.fromJSON(object.claim) : undefined,
      error: isSet(object.error) ? WitnessErrorData.fromJSON(object.error) : undefined,
      signatures: isSet(object.signatures) ? ClaimTunnelResponse_Signatures.fromJSON(object.signatures) : undefined,
    };
  },

  toJSON(message: ClaimTunnelResponse): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = ClaimTunnelRequest.toJSON(message.request);
    }
    if (message.claim !== undefined) {
      obj.claim = ProviderClaimData.toJSON(message.claim);
    }
    if (message.error !== undefined) {
      obj.error = WitnessErrorData.toJSON(message.error);
    }
    if (message.signatures !== undefined) {
      obj.signatures = ClaimTunnelResponse_Signatures.toJSON(message.signatures);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    return ClaimTunnelResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse>): ClaimTunnelResponse {
    const message = createBaseClaimTunnelResponse();
    message.request = (object.request !== undefined && object.request !== null)
      ? ClaimTunnelRequest.fromPartial(object.request)
      : undefined;
    message.claim = (object.claim !== undefined && object.claim !== null)
      ? ProviderClaimData.fromPartial(object.claim)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? WitnessErrorData.fromPartial(object.error)
      : undefined;
    message.signatures = (object.signatures !== undefined && object.signatures !== null)
      ? ClaimTunnelResponse_Signatures.fromPartial(object.signatures)
      : undefined;
    return message;
  },
};

function createBaseClaimTunnelResponse_Signatures(): ClaimTunnelResponse_Signatures {
  return { claimSignature: new Uint8Array(0), resultSignature: new Uint8Array(0) };
}

export const ClaimTunnelResponse_Signatures = {
  encode(message: ClaimTunnelResponse_Signatures, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.claimSignature.length !== 0) {
      writer.uint32(10).bytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      writer.uint32(18).bytes(message.resultSignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClaimTunnelResponse_Signatures {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClaimTunnelResponse_Signatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.claimSignature = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resultSignature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClaimTunnelResponse_Signatures {
    return {
      claimSignature: isSet(object.claimSignature) ? bytesFromBase64(object.claimSignature) : new Uint8Array(0),
      resultSignature: isSet(object.resultSignature) ? bytesFromBase64(object.resultSignature) : new Uint8Array(0),
    };
  },

  toJSON(message: ClaimTunnelResponse_Signatures): unknown {
    const obj: any = {};
    if (message.claimSignature.length !== 0) {
      obj.claimSignature = base64FromBytes(message.claimSignature);
    }
    if (message.resultSignature.length !== 0) {
      obj.resultSignature = base64FromBytes(message.resultSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    return ClaimTunnelResponse_Signatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClaimTunnelResponse_Signatures>): ClaimTunnelResponse_Signatures {
    const message = createBaseClaimTunnelResponse_Signatures();
    message.claimSignature = object.claimSignature ?? new Uint8Array(0);
    message.resultSignature = object.resultSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseInitRequest(): InitRequest {
  return { clientVersion: 0, signatureType: 0 };
}

export const InitRequest = {
  encode(message: InitRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.clientVersion !== 0) {
      writer.uint32(16).int32(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      writer.uint32(24).int32(message.signatureType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InitRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientVersion = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.signatureType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitRequest {
    return {
      clientVersion: isSet(object.clientVersion) ? witnessVersionFromJSON(object.clientVersion) : 0,
      signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0,
    };
  },

  toJSON(message: InitRequest): unknown {
    const obj: any = {};
    if (message.clientVersion !== 0) {
      obj.clientVersion = witnessVersionToJSON(message.clientVersion);
    }
    if (message.signatureType !== 0) {
      obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
    }
    return obj;
  },

  create(base?: DeepPartial<InitRequest>): InitRequest {
    return InitRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitRequest>): InitRequest {
    const message = createBaseInitRequest();
    message.clientVersion = object.clientVersion ?? 0;
    message.signatureType = object.signatureType ?? 0;
    return message;
  },
};

function createBaseRPCMessage(): RPCMessage {
  return {
    id: 0,
    initRequest: undefined,
    initResponse: undefined,
    connectionTerminationAlert: undefined,
    requestError: undefined,
    createTunnelRequest: undefined,
    createTunnelResponse: undefined,
    disconnectTunnelRequest: undefined,
    disconnectTunnelResponse: undefined,
    tunnelMessage: undefined,
    tunnelDisconnectEvent: undefined,
    claimTunnelRequest: undefined,
    claimTunnelResponse: undefined,
  };
}

export const RPCMessage = {
  encode(message: RPCMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.initRequest !== undefined) {
      InitRequest.encode(message.initRequest, writer.uint32(18).fork()).ldelim();
    }
    if (message.initResponse !== undefined) {
      Empty.encode(message.initResponse, writer.uint32(26).fork()).ldelim();
    }
    if (message.connectionTerminationAlert !== undefined) {
      WitnessErrorData.encode(message.connectionTerminationAlert, writer.uint32(34).fork()).ldelim();
    }
    if (message.requestError !== undefined) {
      WitnessErrorData.encode(message.requestError, writer.uint32(42).fork()).ldelim();
    }
    if (message.createTunnelRequest !== undefined) {
      CreateTunnelRequest.encode(message.createTunnelRequest, writer.uint32(50).fork()).ldelim();
    }
    if (message.createTunnelResponse !== undefined) {
      Empty.encode(message.createTunnelResponse, writer.uint32(58).fork()).ldelim();
    }
    if (message.disconnectTunnelRequest !== undefined) {
      DisconnectTunnelRequest.encode(message.disconnectTunnelRequest, writer.uint32(66).fork()).ldelim();
    }
    if (message.disconnectTunnelResponse !== undefined) {
      Empty.encode(message.disconnectTunnelResponse, writer.uint32(74).fork()).ldelim();
    }
    if (message.tunnelMessage !== undefined) {
      TunnelMessage.encode(message.tunnelMessage, writer.uint32(82).fork()).ldelim();
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      TunnelDisconnectEvent.encode(message.tunnelDisconnectEvent, writer.uint32(90).fork()).ldelim();
    }
    if (message.claimTunnelRequest !== undefined) {
      ClaimTunnelRequest.encode(message.claimTunnelRequest, writer.uint32(98).fork()).ldelim();
    }
    if (message.claimTunnelResponse !== undefined) {
      ClaimTunnelResponse.encode(message.claimTunnelResponse, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RPCMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRPCMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.initRequest = InitRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.initResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.connectionTerminationAlert = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestError = WitnessErrorData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTunnelRequest = CreateTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.disconnectTunnelRequest = DisconnectTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.disconnectTunnelResponse = Empty.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tunnelMessage = TunnelMessage.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tunnelDisconnectEvent = TunnelDisconnectEvent.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.claimTunnelRequest = ClaimTunnelRequest.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.claimTunnelResponse = ClaimTunnelResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RPCMessage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      initRequest: isSet(object.initRequest) ? InitRequest.fromJSON(object.initRequest) : undefined,
      initResponse: isSet(object.initResponse) ? Empty.fromJSON(object.initResponse) : undefined,
      connectionTerminationAlert: isSet(object.connectionTerminationAlert)
        ? WitnessErrorData.fromJSON(object.connectionTerminationAlert)
        : undefined,
      requestError: isSet(object.requestError) ? WitnessErrorData.fromJSON(object.requestError) : undefined,
      createTunnelRequest: isSet(object.createTunnelRequest)
        ? CreateTunnelRequest.fromJSON(object.createTunnelRequest)
        : undefined,
      createTunnelResponse: isSet(object.createTunnelResponse)
        ? Empty.fromJSON(object.createTunnelResponse)
        : undefined,
      disconnectTunnelRequest: isSet(object.disconnectTunnelRequest)
        ? DisconnectTunnelRequest.fromJSON(object.disconnectTunnelRequest)
        : undefined,
      disconnectTunnelResponse: isSet(object.disconnectTunnelResponse)
        ? Empty.fromJSON(object.disconnectTunnelResponse)
        : undefined,
      tunnelMessage: isSet(object.tunnelMessage) ? TunnelMessage.fromJSON(object.tunnelMessage) : undefined,
      tunnelDisconnectEvent: isSet(object.tunnelDisconnectEvent)
        ? TunnelDisconnectEvent.fromJSON(object.tunnelDisconnectEvent)
        : undefined,
      claimTunnelRequest: isSet(object.claimTunnelRequest)
        ? ClaimTunnelRequest.fromJSON(object.claimTunnelRequest)
        : undefined,
      claimTunnelResponse: isSet(object.claimTunnelResponse)
        ? ClaimTunnelResponse.fromJSON(object.claimTunnelResponse)
        : undefined,
    };
  },

  toJSON(message: RPCMessage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.initRequest !== undefined) {
      obj.initRequest = InitRequest.toJSON(message.initRequest);
    }
    if (message.initResponse !== undefined) {
      obj.initResponse = Empty.toJSON(message.initResponse);
    }
    if (message.connectionTerminationAlert !== undefined) {
      obj.connectionTerminationAlert = WitnessErrorData.toJSON(message.connectionTerminationAlert);
    }
    if (message.requestError !== undefined) {
      obj.requestError = WitnessErrorData.toJSON(message.requestError);
    }
    if (message.createTunnelRequest !== undefined) {
      obj.createTunnelRequest = CreateTunnelRequest.toJSON(message.createTunnelRequest);
    }
    if (message.createTunnelResponse !== undefined) {
      obj.createTunnelResponse = Empty.toJSON(message.createTunnelResponse);
    }
    if (message.disconnectTunnelRequest !== undefined) {
      obj.disconnectTunnelRequest = DisconnectTunnelRequest.toJSON(message.disconnectTunnelRequest);
    }
    if (message.disconnectTunnelResponse !== undefined) {
      obj.disconnectTunnelResponse = Empty.toJSON(message.disconnectTunnelResponse);
    }
    if (message.tunnelMessage !== undefined) {
      obj.tunnelMessage = TunnelMessage.toJSON(message.tunnelMessage);
    }
    if (message.tunnelDisconnectEvent !== undefined) {
      obj.tunnelDisconnectEvent = TunnelDisconnectEvent.toJSON(message.tunnelDisconnectEvent);
    }
    if (message.claimTunnelRequest !== undefined) {
      obj.claimTunnelRequest = ClaimTunnelRequest.toJSON(message.claimTunnelRequest);
    }
    if (message.claimTunnelResponse !== undefined) {
      obj.claimTunnelResponse = ClaimTunnelResponse.toJSON(message.claimTunnelResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<RPCMessage>): RPCMessage {
    return RPCMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RPCMessage>): RPCMessage {
    const message = createBaseRPCMessage();
    message.id = object.id ?? 0;
    message.initRequest = (object.initRequest !== undefined && object.initRequest !== null)
      ? InitRequest.fromPartial(object.initRequest)
      : undefined;
    message.initResponse = (object.initResponse !== undefined && object.initResponse !== null)
      ? Empty.fromPartial(object.initResponse)
      : undefined;
    message.connectionTerminationAlert =
      (object.connectionTerminationAlert !== undefined && object.connectionTerminationAlert !== null)
        ? WitnessErrorData.fromPartial(object.connectionTerminationAlert)
        : undefined;
    message.requestError = (object.requestError !== undefined && object.requestError !== null)
      ? WitnessErrorData.fromPartial(object.requestError)
      : undefined;
    message.createTunnelRequest = (object.createTunnelRequest !== undefined && object.createTunnelRequest !== null)
      ? CreateTunnelRequest.fromPartial(object.createTunnelRequest)
      : undefined;
    message.createTunnelResponse = (object.createTunnelResponse !== undefined && object.createTunnelResponse !== null)
      ? Empty.fromPartial(object.createTunnelResponse)
      : undefined;
    message.disconnectTunnelRequest =
      (object.disconnectTunnelRequest !== undefined && object.disconnectTunnelRequest !== null)
        ? DisconnectTunnelRequest.fromPartial(object.disconnectTunnelRequest)
        : undefined;
    message.disconnectTunnelResponse =
      (object.disconnectTunnelResponse !== undefined && object.disconnectTunnelResponse !== null)
        ? Empty.fromPartial(object.disconnectTunnelResponse)
        : undefined;
    message.tunnelMessage = (object.tunnelMessage !== undefined && object.tunnelMessage !== null)
      ? TunnelMessage.fromPartial(object.tunnelMessage)
      : undefined;
    message.tunnelDisconnectEvent =
      (object.tunnelDisconnectEvent !== undefined && object.tunnelDisconnectEvent !== null)
        ? TunnelDisconnectEvent.fromPartial(object.tunnelDisconnectEvent)
        : undefined;
    message.claimTunnelRequest = (object.claimTunnelRequest !== undefined && object.claimTunnelRequest !== null)
      ? ClaimTunnelRequest.fromPartial(object.claimTunnelRequest)
      : undefined;
    message.claimTunnelResponse = (object.claimTunnelResponse !== undefined && object.claimTunnelResponse !== null)
      ? ClaimTunnelResponse.fromPartial(object.claimTunnelResponse)
      : undefined;
    return message;
  },
};

function createBaseRPCMessages(): RPCMessages {
  return { messages: [] };
}

export const RPCMessages = {
  encode(message: RPCMessages, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.messages) {
      RPCMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RPCMessages {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRPCMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(RPCMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RPCMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => RPCMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RPCMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => RPCMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RPCMessages>): RPCMessages {
    return RPCMessages.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RPCMessages>): RPCMessages {
    const message = createBaseRPCMessages();
    message.messages = object.messages?.map((e) => RPCMessage.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
